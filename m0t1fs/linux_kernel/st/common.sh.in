#!/usr/bin/env bash

# This script is also used by utils/ut.sh, utils/linux_kernel/ut.sh
# If you are modifying this file, please make the relevant changes
# in above mentioned files also.

MODLIST="@abs_top_srcdir@/m0tr.ko"

# The following associative array carries the list of module parameters for
# modules in MODLIST.
declare -A MODPARAMS
NULL_UUID="00000000-0000-0000-0000-000000000000"
M0_MODULE_TRACE_MASK='!all'
M0_TRACE_PRINT_CONTEXT=short
M0_TRACE_LEVEL='fatal+'

# Get Intel ISA library
ISAL_LIBS=@ISAL_LIBS@

MODPARAMS[m0tr.ko]="node_uuid=${NODE_UUID:-$NULL_UUID}"

MODPARAMS[m0ut.ko]="node_uuid=${NODE_UUID:-$NULL_UUID} \
		    trace_immediate_mask=${M0_MODULE_TRACE_MASK} \
		    trace_print_context=${M0_TRACE_PRINT_CONTEXT} \
		    trace_level=${M0_TRACE_LEVEL} \
		    ${tests:+tests=$tests} \
		    ${exclude_tests:+exclude=$exclude_tests}"

# to make command output parsing predictable
export LC_MESSAGES=C

# libisal does not need kernel based ST
LIBISAL_TESTS_SKIPLIST=(
	"spiel-sns-repair"
	"spiel-sns-repair-quiesce"
	"sns-repair-mf"
	"sns-repair-rebalance-quiesce"
	"failure-after-sns-repair-rebalance-quiesce"
	"sns-repair-abort"
	"sns-repair-ios-fail"
	"sns-repair-abort-repair-quiesce-rebalance-quiesce"
)

abort()
{
	echo "$1 Aborting."
	exit 1
}

# Do not rmmod lnet, it may be used by lustre
modprobe_lnet()
{
	modprobe lnet || abort "Error probing lnet."
}

modload_galois()
{
	BASE=@GALOIS_ABS_SRC@
	if [ -z "$BASE" ]; then
		modprobe galois
	else
		insmod $BASE/src/linux_kernel/galois.ko
	fi
}

modunload_galois()
{
	rmmod galois &> /dev/null
}

modload()
{
	local m
	for m in $MODLIST; do
		local BN=$(basename $m)
		local PARAMS=
		if [[ ! -z "${MODPARAMS[$BN]}" ]]; then
		    PARAMS=${MODPARAMS[$BN]}
		fi
		insmod $m $PARAMS || abort "Error loading $m $PARAMS"
	done
}

modunload()
{
	local m
	local rc=0
	for m in $MODLIST; do
		echo $m
	done | tac | while read; do
		rmmod $REPLY &> /dev/null || {
			rc=$?
			echo "Error unloading $REPLY." >&2
		}
	done
	return $rc
}

# Check if given testname is present in the skip list.
# Return 1 if present in skip list, else return 0.
# arg1 : name of test to be checked
# arg2 : array of tests to be skipped
_check_skip_list() {
    testname=$1; shift
    test_skip_list=($@)

    for test in "${test_skip_list[@]}"
    do
        if [[ "$test" == "$testname" ]]; then
            return 1
        fi
    done
}

check_test_skip_list()
{
	# Check if we are using Intel ISA library
	if [ ! -z "$ISAL_LIBS" ]; then
		_check_skip_list $1 ${LIBISAL_TESTS_SKIPLIST[@]}
		if [[ "$?" != 0 ]]; then
			echo =================================================
			echo == SKIP this test when we are using Intel ISA ===
			echo =================================================
			return 1
		fi
	fi
}
