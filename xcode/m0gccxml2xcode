#!/usr/bin/env perl
#
# Copyright (c) 2012-2020 Seagate Technology LLC and/or its Affiliates
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# For any questions about this software or licensing,
# please email opensource@seagate.com or cortx-questions@seagate.com.
#


# This script generates m0 xcode data from gccxml's output.

# For detailed description and usage information please refer to the POD
# documentation at the end of file, after the __END__ marker.


BEGIN {

# check that all required external modules are available and display a hint to
# the user about how they can be installed using default package management
# system, if they are missing

    my $some_module_is_missing = 0;

    my $check_module_availability = sub {

        my ($module, $deb_pkg, $redhat_pkg) = @_;

        my $module_name = $module;

        $module_name =~ s/\.pm$//xms;
        $module_name =~ s#/#::#g;

        if (eval { require $module; 1; } ne 1) {
            $some_module_is_missing = 1;
            print "$module_name perl module is missing\n"
                  . "   It can be installed manually or using package management system:\n"
                  . "     debian based:  apt-get install $deb_pkg\n"
                  . "     red-hat based: yum install $redhat_pkg\n"
                  . "     manually:      cpanm $module_name\n\n";
        }
    };

    # check XML::LibXML module
    &$check_module_availability('XML/LibXML.pm', 'libxml-libxml-perl',
                                                 'perl-XML-LibXML');

    # check YAML::XS module
    &$check_module_availability('YAML/XS.pm', 'libyaml-libyaml-perl',
                                              'perl-YAML-LibYAML');

    # check List::MoreUtils module
    &$check_module_availability('List/MoreUtils.pm', 'liblist-moreutils-perl',
                                                     'perl-List-MoreUtils');

    # check File::Slurp module
    &$check_module_availability('File/Slurp.pm', 'libfile-slurp-perl',
                                                 'perl-File-Slurp');

    die 'Please, install all required modules'
        if ($some_module_is_missing);
}


# enable all features of Modern Perl, almost the same as done by Modern::Perl
# module, but doesn't require it as dependency
use 5.010;
use strict;
use warnings;
# suppress experimental warnings about 'given' and 'when'
# on more recent Perl versions
use feature qw( switch );
no if $] >= 5.018, warnings => 'experimental::smartmatch';

# core modules
use Carp;
use File::Basename;
use Getopt::Long qw( :config no_ignore_case );
use Pod::Usage;
use Fatal qw( open close );
use English qw( -no_match_vars ); # avoids regex performance penalty
use Fcntl qw( :flock );
use Scalar::Util qw( looks_like_number );

# external modules (not included into base perl distribution)
use XML::LibXML;
use YAML::XS;
use List::Util qw[min max];
use List::MoreUtils qw( none );
use File::Slurp;  # TODO: use 'qw( :std :edit )' when moved to Centos7
#use Data::Dumper;
#use Devel::StackTrace;

# ###############################################
#  Parser
# ###############################################

my $header_file_name;
my $header_file_path;
my $header_file_id;
my $xcode_path;
my $xcode_id;
my $include_protector_name;
my $xlist_block_start;
my $xlist_block_end;
my $xlist_block_placeholder;
my $dom;
my $gccxml_attr;

my %cli_option  = (
    'input_file_name' => '-' # STDIN
);


sub get_member_nodes_of
{
    my $node = shift;
    my @member_nodes;

    if ($node->getAttribute('members')) {
        my @member_ids = split /\s+/, $node->getAttribute('members');

        for my $member_id (@member_ids) {
            # The 'members' attribute may contain not only direct members of
            # structure, so we need to search by id only for <Field> tags which
            # are direct members of our node.
            my ($member_node) = $dom->findnodes(qq{//Field[\@id='$member_id']});

            if (defined $member_node) {
                push @member_nodes, $member_node;
            }
        }
    }
    # Handle enumerations.
    for my $enum_val ($node->findnodes('./EnumValue')) {
        push @member_nodes, $enum_val;
    }
    return @member_nodes;
}

sub get_type_node_of
{
    my $node = shift;

    my $type_id = $node->getAttribute('type');

    return
        if !defined $type_id;

    my ($type_node) = $dom->findnodes(qq{//*[\@id='$type_id']});

    return $type_node;
}

sub get_file_name_of
{
    my $node = shift;

    my $file_id = $node->getAttribute('file');
    my ($file_node) = $dom->findnodes(qq{//File[\@id='$file_id']});

    return $file_node->getAttribute('name');
}

sub set_item_attr
{
    my ($item, $node) = @_;

    my $item_attr_string = $node->getAttribute('attributes') // '';
    my $type_node        = get_type_node_of($node);

    if (defined $type_node) {
        $item_attr_string .= $type_node->getAttribute('attributes') // '';
    }

    if ($item_attr_string ne '') {
        while ($item_attr_string =~ / $gccxml_attr \( (?<name>\w+) , (?<value>[\w|]+) \) /xmsg)
        {
            croak "Incorrect format of gccxml attributes near " . $item->{'name'}
                . ' at ' . get_file_name_of($node) . ':'
                . $node->getAttribute('line')
                if !defined $+{name} || !defined $+{value};

            $item->{'attribute'}{$+{name}} = $+{value};

            if ($+{name} eq 'xc_tag' && !looks_like_number($+{value})) {
                my ($enum_node) = $dom->findnodes(qq{//EnumValue[\@name='$+{value}']});

                die "Error: failed to find definition of '$+{value}' enum value"
                    . " in '$header_file_path', did you forget to include a"
                    . " header which defines it?\n"
                    if !defined $enum_node;

                $item->{'attribute'}{'xc_tag_num'} = $enum_node->getAttribute('init');
            }
        }
    }
}

# this function is modeled after m0_xcode_type_invariant() from xcode/xcode.c
# and it should be kept in sync with it's C ancestor if the latter is changed
sub check_xc_atype_invariant
{
    my $item = shift;

    my %xc_atype = (
        M0_XA_RECORD    => { min_members => 0, max_members => ~0 },
        M0_XA_UNION     => { min_members => 2, max_members => ~0 },
        M0_XA_SEQUENCE  => { min_members => 2, max_members => 2 },
        M0_XA_ARRAY     => { min_members => 1, max_members => 1 },
        M0_XA_TYPEDEF   => { min_members => 1, max_members => 1 },
        M0_XA_OPAQUE    => { min_members => 0, max_members => 0 },
        M0_XA_BLOB      => { min_members => 1, max_members => 1 },
        M0_XA_ATOM      => { min_members => 0, max_members => 0 },
    );

    my $type = "$item->{'type'} $item->{'name'}";

    croak "Error: $type should have 'xc_atype' gccxml __attribute__, please"
            . " use an appropriate M0_XCA_* macro to set it"
        if !defined $item->{'attribute'}
           || !defined $item->{'attribute'}->{'xc_atype'};

    my $atype = $item->{'attribute'}->{'xc_atype'};

    croak "Error: Incorrect value ($atype) of 'xc_atype' attribute of '$type',"
            . " please use one of the following values: @{[ keys %xc_atype ]}"
        if none { $atype eq $_ } keys %xc_atype;

    my $members_number = count_members_of($item);
    my $min            = $xc_atype{$atype}->{'min_members'};
    my $max            = $xc_atype{$atype}->{'max_members'};

    croak "Error: incorrect number of members ($members_number) of '$type',"
            . " it should be in range [$min, $max]"
        if $members_number < $min || $members_number > $max;

    # ensure that first field of UNION or SEQUENCE is of type M0_XT_U8,
    # M0_XT_U32, M0_XT_U64 or M0_XT_VOID
    croak "Error: first field of '$type' should be of integral type,"
            . " but it's '$item->{'members'}->[0]->{'type'}' instead"
        if $atype =~ /M0_XA_UNION|M0_XA_SEQUENCE/
           && $item->{'members'}->[0]->{'xc_type'} !~ /M0_XT_(?:U\d{1,2}|VOID)/;
}

sub get_info_about
{
    my $node  = shift;
    my %param = (%{{recursive => 1, xc_atype => ''}}, @_);

    my $item->{'name'}   = $node->getAttribute('name');
       $item->{'offset'} = $node->getAttribute('offset');
    my $type_node        = get_type_node_of($node);

    set_item_attr($item, $node);

    given ($type_node->nodeName()) {
        when ('FundamentalType') {
            $item->{'size'}    = $type_node->getAttribute('size');
            $item->{'type'}    = $type_node->getAttribute('name');

            # Normally, a 'void' C type can't be a valid type of a variable and
            # thus it doesn't have a corresponding xcode M0_XT_XXX type. But
            # just in case of some internal logic error in this script, when
            # 'void' could "leak" into generated code, we set xc_type for 'void'
            # to 'UNDEFINED' which will lead to compilation error, so it would
            # be easier to sort such error out.
            $item->{'xc_type'} = $item->{'type'} eq 'void'
                                    ? 'UNDEFINED'
                                    : '&M0_XT_U' . $item->{'size'};
        }

        when ('Typedef') {
            $item->{'size'}    = get_info_about($type_node, %param)->{'size'};
            $item->{'type'}    = $type_node->getAttribute('name');
            $item->{'xc_type'} = get_info_about($type_node, %param)->{'xc_type'};
        }

        when ('CvQualifiedType') {
            $item->{'size'}    = get_info_about($type_node, %param)->{'size'};
            $item->{'type'}    = 'const ' . get_info_about($type_node, %param)->{'type'};
            $item->{'xc_type'} = get_info_about($type_node, %param)->{'xc_type'};
        }

        when ('PointerType') {
            my $tn_info = get_info_about($type_node, %param, recursive => 0);

            $item->{'size'} = $type_node->getAttribute('size');
            $item->{'type'} = $tn_info->{'type'} . '*';

            $item->{'xc_type'}
                  # if parent structure is an xcode sequence, the xcode type of
                  # the pointed object should be used unless it's a pointer to
                  # 'void'
                = $param{'xc_atype'} eq 'M0_XA_SEQUENCE'
                  # pointer to 'void' is treated specially, because 'void' type
                  # doesn't have size, but 'void*' is a commonly used type for
                  # buffers; in order to be able to serialize such buffers with
                  # xcode, we set it the same as a pointer to 'unsigned char'
                  # or 'u8'
                ? ( $tn_info->{'type'} eq 'void' ? '&M0_XT_U8' : $tn_info->{'xc_type'} )
                  # otherwise a pointer is encoded as a 'uint64_t' value, this
                  # is currently useful only for m0protocol, xcode runtime
                  # doesn't support pointers anywhere except in a sequence or
                  # when it's marked as opaque
                : '&M0_XT_U64';

            if ($tn_info->{'type'} ne 'void') {
                $item->{'attribute'}{'xc_domain'} = $tn_info->{'attribute'}{'xc_domain'};
            }
        }

        when ('FunctionType') {
            # this type is used for pointers to a function, for now it's
            # hard-coded as a 'void*' of size 64bits; this won't work in
            # run-time for encoding/decoding because core xcode implementation
            # doesn't support it, but this is enough to provide meta-information
            # to `m0protocol`
            $item->{'size'}    = 64;
            $item->{'type'}    = 'void';
            $item->{'xc_type'} = '&M0_XT_U64';
        }

        when ('ArrayType') {
            $item->{'size'} = $type_node->getAttribute('size');

            # CastXML doesn't add size attribute to array types. Calculate it
            # manually if absent.
            if (not defined($item->{'size'}) and $item->{'name'} ne 'm0_void_t') {
                my $tn_info = get_info_about($type_node, %param);
                my $max = $type_node->getAttribute('max');
                my $min = $type_node->getAttribute('min');

                die if not defined($max);
                die if not defined($min);
                die if not defined($tn_info->{'size'});

                $item->{'size'} = ($max - $min + 1) * $tn_info->{'size'};
            }
            if (not defined($item->{'size'}) and $item->{'name'} eq 'm0_void_t') {
                $item->{'size'} = 0;
            }

            if ($item->{'name'} eq 'm0_void_t' or $item->{'size'} == 0) {
                # a special-case array `typedef char m0_void_t[0];` which is an
                # xcode stub to trick C compiler, it requires these special
                # handling:
                #   1. 'xc_type' should be '&M0_XT_VOID'
                #   2. 'type' field should be absent
                # OR a gcc extension for zero-length array field at the end of a
                # struct, which should be treated the same way as 'm0_void_t' to
                # avoid incorrect struct size calculation
                $item->{'xc_type'} = '&M0_XT_VOID';
            }
            else {
                my $tn_info = get_info_about($type_node, %param);

                $item->{'xc_type'} = $tn_info->{'xc_type'};
                $item->{'type'}    = $tn_info->{'type'};

                $item->{'attribute'}->{'xc_tag'} = $item->{'size'} / $tn_info->{'size'};
            }
        }

        when (/Struct|Union/) {
            my $entity_name    = lc $type_node->nodeName();
            my $item_type_name = $type_node->getAttribute('name') // 'anonymous';

            $item->{'size'}    = $type_node->getAttribute('size');
            $item->{'type'}    = "$entity_name " . ($item_type_name // 'anonymous');
            $item->{'xc_type'} = $item_type_name eq 'm0_void_t' ? '&M0_XT_VOID'
                                 :                                $item_type_name . '_xc'
                                 ;

            # if sturct/union is defined in current header file (the one we
            # are processing), then also get information about its members
            if ($type_node->getAttribute('file') eq $header_file_id && $param{'recursive'})
            {
                my @member_nodes = get_member_nodes_of($type_node);

                for my $member_node (@member_nodes) {
                    my $atype = $item->{'attribute'}->{'xc_atype'};
                    push @{$item->{'members'}}
                         , get_info_about($member_node
                                          , defined $atype ? (xc_atype => $atype) : ());
                }
            }
            else {
                $item->{'members'} = [];
            }
        }

        default {
            croak "Unhandled node type '" . $type_node->nodeName() . "'";
        }
    }

    if (exists $item->{'attribute'}{'xc_opaque'}) {
        $item->{'xc_type'} = '&M0_XT_OPAQUE';
    }

    return $item;
}

sub count_members_of
{
    my $item = shift;

    # count union fields as a direct members of enclosing structure, so each
    # union is counted as many times as many members it has
    return scalar map {
                        defined $_->{'type'} && $_->{'type'} =~ /union/
                        ? @{$_->{'members'}} : $_
                      }
                      @{$item->{'members'}};
}

sub flags_of
{
    my $item = shift;

    my @flags;

    if (defined $item->{'attribute'}{'xc_domain'}) {
        push @flags,
             map { 'M0_XCODE_TYPE_FLAG_DOM_' . uc $_ }
             split(/\|/, $item->{'attribute'}{'xc_domain'});
    }

    if (!@flags) {
        push @flags, 0;
    }

    return join ' | ', @flags;
}

sub get_global_namespace_id
{
    my ($global_ns_node) = $dom->findnodes(qq{//Namespace[\@name='::']});
    return $global_ns_node->getAttribute('id');
}

sub get_header_file_id
{
    my ($header_file_node) = $dom->findnodes(qq{//File[contains(\@name, '$header_file_path')]});

    croak "Error: unable to find xml tag for header file '$header_file_path' in"
          . " the gccxml's output.\n\nPlease, notice that gccxml writes an exact"
          . " path of it's input arguments into output xml, so input files for"
          . " gccxml and m0gccxml2xcode should use the same path, for example:\n"
          . "   gccxml -fxml=my_header.gccxml path/to/header/my_header.h\n"
          . "   m0gccxml2xcode -i path/to/header/my_header.gccxml\n"
          . "\n"
          . "But not a:\n"
          . "   gccxml -fxml=my_header.gccxml path/to/header/my_header.h\n"
          . "   m0gccxml2xcode -i my_header.gccxml\n"
          . "\n"
          . "Or:\n"
          . "   gccxml -fxml=my_header.gccxml my_header.h\n"
          . "   m0gccxml2xcode -i path/to/header/my_header.gccxml\n"
          . "\n"
        if !defined $header_file_node;

    return $header_file_node->getAttribute('id');
}

sub init_xml_parser
{
    my $gccxml_file = shift;

    #
    # parse gccxml file
    #

    $dom = XML::LibXML->load_xml(IO => $gccxml_file);

    # index all DOM elements to considerably speeds up XPath queries for large
    # xml documents.
    $dom->indexElements();

    # set global variables
    $header_file_id = get_header_file_id();

    return;
}

sub process_node
{
    my ($node, $enump) = @_;

    my $item;
    $item->{'type'}    = lc $node->nodeName();
    $item->{'name'}    = $node->getAttribute('name');
    $item->{'size'}    = $node->getAttribute('size');

    set_item_attr($item, $node);

    my $atype = $item->{'attribute'}->{'xc_atype'};

    if (defined $atype && $atype eq 'M0_XA_BLOB') {
        # ignore real members of a "blob" structure and create a single fake
        # array member with size of the whole structure
        $item->{'is_blob'} = 1;
        $item->{'attribute'}->{'xc_atype'} = 'M0_XA_ARRAY';
        $item->{'members'} = [{
                name      => 'blob',
                xc_type   => '&M0_XT_U8',
                offset    => 0,
                size      => $item->{'size'},
                attribute => {
                    # gccxml provides offset and size values in bits
                    xc_tag   => $item->{'size'} / 8,
                },
        }];
    }
    else {
        # get information about all members
        my @member_nodes = get_member_nodes_of($node);
        for my $member_node (@member_nodes) {
            push @{$item->{'members'}}
            , $enump ? $member_node
            :          get_info_about($member_node
                , defined $atype ? (xc_atype => $atype) : ());
        }
    }

    $item->{'scope'}
        = $node->getAttribute('context') eq get_global_namespace_id() ? '' : 'static ';

    return $item;
}

sub build_item_list
{
    my $gccxml_file_name = shift;

    init_xml_parser($gccxml_file_name);

    # find all structures which are defined in our header file
    # and have gccxml attribute
    my @struct_nodes
        = $dom->findnodes(qq{//Struct[\@file='$header_file_id'
                                      and not(\@incomplete)
                                      and contains(\@attributes, '$gccxml_attr')]});
    my @items;

    for my $struct_node (@struct_nodes) {
        my $item = process_node($struct_node, 0);
        check_xc_atype_invariant($item);
        push @items, $item;
    }

    my @enum_nodes
        = $dom->findnodes(qq{//Enumeration[\@file='$header_file_id'
                                      and not(\@incomplete)
                                      and contains(\@attributes, '$gccxml_attr')]});
    my @enums;
    for my $enum_node (@enum_nodes) {
        my $enum = process_node($enum_node, 1);
        push @enums, $enum;
    }
    return (\@items, \@enums);
}

# ###############################################
#  Generator
# ###############################################

sub gen_xc_h_header
{
    return <<"END_HEADER"
/* This file is automatically generated from $header_file_name */

#pragma once

#ifndef $include_protector_name
#define $include_protector_name

#ifndef __KERNEL__
#include <sys/types.h>
#endif

#include "xcode/xcode.h"

END_HEADER
}

sub gen_xc_h_footer
{
    return <<"END_FOOTER"

/* $include_protector_name */
#endif

END_FOOTER
}

sub gen_xc_h
{
    my ($items, $enums) = @_;

    my $xcode = gen_xc_h_header();

    # forward declarations of xcode type pointers for all global structures
    for my $item (grep { $_->{'scope'} !~ /static/ } @$items) {
        $xcode .= "#if !defined(__KERNEL__)\n"
                  if defined $item->{'attribute'}{'xc_domain'}
                     && $item->{'attribute'}{'xc_domain'} eq 'be';
        $xcode .= "extern struct m0_xcode_type *$item->{name}_xc;\n";
        $xcode .= "#endif\n"
                  if defined $item->{'attribute'}{'xc_domain'}
                     && $item->{'attribute'}{'xc_domain'} eq 'be';
    }
    $xcode .= "\n";

    # prototypes of init function for all global structures
    for my $item (@$items) {
        $xcode .= "#if !defined(__KERNEL__)\n"
                  if defined $item->{'attribute'}{'xc_domain'}
                     && $item->{'attribute'}{'xc_domain'} eq 'be';
        $xcode .= "M0_INTERNAL void m0_xc_$item->{name}_struct_init(void);\n";
        $xcode .= "#endif\n"
                  if defined $item->{'attribute'}{'xc_domain'}
                     && $item->{'attribute'}{'xc_domain'} eq 'be';
    }
    $xcode .= "\n";

    # prototypes of enum descriptors
    for my $e (@$enums) {
        $xcode .= "extern struct m0_xcode_enum m0_xc_$e->{name}_enum;\n";
    }
    $xcode .= "\n";

    # prototypes of xcode init/fini functions
    $xcode .= "M0_INTERNAL void m0_xc_${xcode_id}_init(void);\n";
    $xcode .= "M0_INTERNAL void m0_xc_${xcode_id}_fini(void);\n";

    $xcode .= gen_xc_h_footer();
}

sub gen_xc_c_header
{
    return <<"END_HEADER"
/* This file is automatically generated from $header_file_name */

#include "lib/misc.h"                       /* offsetof */
#include "lib/assert.h"
#include "xcode/xcode.h"

#include "$header_file_name"
#include "${xcode_path}_xc.h"

END_HEADER
}

# call visitor function for each item and it's members recursively
sub walk_members_tree
{
    my ($items_ref, $visitor_func) = @_;

    for my $item (@$items_ref) {
        for my $member (@{$item->{'members'}}) {
            &$visitor_func($member);
            if (defined $member->{'members'}) {
                walk_members_tree($member->{'members'}, $visitor_func);
            }
        }
    }
}

# generate declarations of xcode type pointers
sub gen_xc_c_type_struct_decl
{
    my @items = @_;

    my $xcode = "";

    for my $item (@items) {
        $xcode .= "#if !defined(__KERNEL__)\n"
                  if defined $item->{'attribute'}{'xc_domain'}
                     && $item->{'attribute'}{'xc_domain'} eq 'be';
        $xcode .= $item->{'scope'} . 'struct m0_xcode_type *' . $item->{'name'} . "_xc;\n";
        $xcode .= "#endif\n"
                  if defined $item->{'attribute'}{'xc_domain'}
                     && $item->{'attribute'}{'xc_domain'} eq 'be';
    }

    return $xcode;
}

# generate declarations of xcode opaque callbacks
sub gen_xc_c_opaque_func_decl
{
    my @items = @_;

    my $xcode = '';
    my $gen_opaque_func_decl = sub {
        my $item = shift;
        if (defined $item->{'attribute'} && defined $item->{'attribute'}->{'xc_opaque'}) {
            $xcode .= "#if !defined(__KERNEL__)\n"
                      if defined $item->{'attribute'}{'xc_domain'}
                         && $item->{'attribute'}{'xc_domain'} eq 'be';
            $xcode .= 'int ' . $item->{'attribute'}->{'xc_opaque'}
                      . "(const struct m0_xcode_obj *par,\n\t\t"
                      . "const struct m0_xcode_type **out);\n";
            $xcode .= "#endif\n"
                      if defined $item->{'attribute'}{'xc_domain'}
                          && $item->{'attribute'}{'xc_domain'} eq 'be';
        }
    };

    walk_members_tree(\@items, $gen_opaque_func_decl);

    return $xcode . "\n";
}

# generate definitions and initializations of helper type structures
sub gen_xc_c_helper_type_struct_def
{
    my @items = @_;

    my $xcode = "";

    for my $item (@items) {

        my $name           = $item->{'name'};
        my $type           = $item->{'type'};
        my $xc_atype       = $item->{'attribute'}->{'xc_atype'};
        my $scope          = $item->{'scope'};
        my $members_number = count_members_of($item);
        my $flags          = flags_of($item);

        $xcode .= "#if !defined(__KERNEL__)\n"
                  if defined $item->{'attribute'}{'xc_domain'}
                     && $item->{'attribute'}{'xc_domain'} eq 'be';
        $xcode .= <<"END_STRUCT"
static struct _${name}_s {
\tstruct m0_xcode_type  _type;
\tstruct m0_xcode_field _child[$members_number];
} _$name = {
\t._type = {
\t\t.xct_aggr   = $xc_atype,
\t\t.xct_name   = "$name",
\t\t.xct_sizeof = sizeof ($type $name),
\t\t.xct_nr     = $members_number,
\t\t.xct_flags  = $flags,
\t}
};

${scope}struct m0_xcode_type *${name}_xc = &_${name}._type;
M0_BASSERT(offsetof(struct _${name}_s, _child[0]) ==
\toffsetof(struct m0_xcode_type, xct_child[0]));
END_STRUCT
;
        $xcode .= "#endif\n"
                  if defined $item->{'attribute'}{'xc_domain'}
                     && $item->{'attribute'}{'xc_domain'} eq 'be';
        $xcode .= "\n";
    }

    return $xcode . "\n";
}

sub gen_xc_c_compiletime_checks
{
    my @items = @_;

    my $xcode = "";

    for my $item (@items) {

        my $name = $item->{'name'};
        my $type = $item->{'type'};

        # NOTICE: gccxml provides offset and size values in bits, so we need to
        # convert them into units of C sizeof - bytes (actually not bytes, but
        # units of sizeof(char) in size, so more portable solution would be to
        # divide values, provided by gccxml, in sizeof(char) directly in the
        # generated C code)
        my $size = $item->{'size'} / 8;

        $xcode .= "#if !defined(__KERNEL__)\n"
                  if defined $item->{'attribute'}{'xc_domain'}
                     && $item->{'attribute'}{'xc_domain'} eq 'be';
        $xcode .= "M0_BASSERT(sizeof($type $name) == ${size}U);\n";
        $xcode .= "#endif\n"
                  if defined $item->{'attribute'}{'xc_domain'}
                     && $item->{'attribute'}{'xc_domain'} eq 'be';
        $xcode .= "\n";

        return $xcode . "\n"
            if defined $item->{'is_blob'};

        for my $member (@{$item->{'members'}}) {

            # see above notice about sizes
            my $member_size   = $member->{'size'} / 8;
            my $member_offset = $member->{'offset'} / 8;
            my $union_field = '';

            my $gen_child_check = sub {

                my $child = shift;

            $xcode .= "#if !defined(__KERNEL__)\n"
                      if defined $item->{'attribute'}{'xc_domain'}
                         && $item->{'attribute'}{'xc_domain'} eq 'be';
            $xcode .= <<"END_BASSERT"
M0_BASSERT(sizeof (($type $name *)0)->$member->{'name'}$union_field == ${member_size}U);
M0_BASSERT(offsetof($type $name, $member->{'name'}$union_field) == ${member_offset}U);
END_BASSERT
;
            $xcode .= "#endif\n"
                      if defined $item->{'attribute'}{'xc_domain'}
                         && $item->{'attribute'}{'xc_domain'} eq 'be';
            };

            if (defined $member->{'type'} && $member->{'type'} =~ /union/) {
                # if member type is union, than generate code for each
                # field of the union instead of union itself
                for my $union_member (@{$member->{'members'}}) {
                    # see above notice about sizes
                    $member_size   = $union_member->{'size'} / 8;
                    $union_field   = '.' . $union_member->{'name'};
                    &$gen_child_check($union_member);
                }
            }
            else {
                # if member type is other than union, that generate code
                # for the member itself
                &$gen_child_check($member);
            }
        }

        $xcode .= "\n";
    }

    return $xcode . "\n";
}

# generate xcode init func for particular data structure
sub gen_xc_c_init_func_for
{
    my $item = shift;

    my $xcode;
    $xcode  = "#if !defined(__KERNEL__)\n"
              if defined $item->{'attribute'}{'xc_domain'}
                 && $item->{'attribute'}{'xc_domain'} eq 'be';
    $xcode .= "M0_INTERNAL void m0_xc_$item->{'name'}_struct_init(void)\n{\n";
    my $child_idx = 0;

    for my $member (@{$item->{'members'}}) {

        my $union_field = '';

        my $gen_child_init = sub {

            my $child = shift;

            my $xc_tag = 0;
            my $opaque_func_name = 'NULL';
            my $fenum = 'NULL';
            my $fbitmask = 'NULL';
            my $fread = 'NULL';
            my $fdecor = 'NULL';
            my $offset = defined $item->{'is_blob'} ? $child->{'offset'}
                       : "offsetof($item->{'type'} $item->{'name'}, $member->{'name'}$union_field)";

            if (defined $child->{'attribute'}) {
                $xc_tag = $child->{'attribute'}->{'xc_tag'} // 0;
                $opaque_func_name = $child->{'attribute'}->{'xc_opaque'} // 'NULL';
                $fenum = $child->{'attribute'}->{'xc_fenum'} // 'NULL';
                $fbitmask = $child->{'attribute'}->{'xc_fbitmask'} // 'NULL';
            }
            if ($fenum ne 'NULL' && $fbitmask ne 'NULL') {
                croak "Error: both enum ($fenum) and bitmask ($fbitmask) " . 
                    "are specified for $child."
            }
            if ($fenum ne 'NULL') {
                $fread = "&m0_xcode_enum_field_read";
                $fdecor = "&m0_xc_" . $fenum . "_enum";
            }
            if ($fbitmask ne 'NULL') {
                $fread = "&m0_xcode_bitmask_field_read";
                $fdecor = "&m0_xc_" . $fbitmask . "_enum";
            }

            my $before_type = '';
            my $after_type  = '';
            if (defined $child->{'attribute'}{'xc_domain'}
                && $child->{'attribute'}{'xc_domain'} eq 'be')
            {
                $before_type = <<"END_BEFORE_TYPE"
#ifdef __KERNEL__
\t\t.xf_type   = &M0_XT_VOID,
#else
END_BEFORE_TYPE
;
                $after_type = "#endif";
            }

            $xcode .= <<"END_CHILD_INIT"
\t_$item->{'name'}._child[$child_idx] = (struct m0_xcode_field) {
\t\t.xf_name   = "$child->{'name'}",
$before_type
\t\t.xf_type   = $child->{'xc_type'},
$after_type
\t\t.xf_tag    = $xc_tag,
\t\t.xf_opaque = $opaque_func_name,
\t\t.xf_offset = $offset,
\t\t.xf_read   = $fread,
\t\t.xf_decor  = {
\t\t\t[M0_XCODE_DECOR_READ] = $fdecor
\t\t}
\t};
END_CHILD_INIT
;
            $xcode .= "#if !defined(__KERNEL__)\n"
                      if defined $child->{'attribute'}{'xc_domain'}
                         && $child->{'attribute'}{'xc_domain'} eq 'be';

            # call XC init function for child's type
            given($child->{'xc_type'}) {
                when (/M0_XT_(U\d{1,2}|VOID|OPAQUE)/) {
                    $xcode .= "\tm0_xc_" . lc($1) . "_init();\n";
                }
                when (/^(.*)_xc$/) {
                    $xcode .= "\tm0_xc_${1}_struct_init();\n";
                }
                default {
                    croak "Unhandled xc_type in child init function generation for"
                          . " $item->{'name'}::$child->{'name'}: $child->{'xc_type'}";
                }
            }

            $xcode .= "#endif\n"
                      if defined $child->{'attribute'}{'xc_domain'}
                         && $child->{'attribute'}{'xc_domain'} eq 'be';
            $xcode .= "\n";

            $child_idx++;
        };

        if (defined $member->{'type'} && $member->{'type'} =~ /union/) {
            # if member type is union, than generate init code for each
            # field of the union instead of union itself
            for my $union_member (@{$member->{'members'}}) {
                $union_field = '.' . $union_member->{'name'};
                &$gen_child_init($union_member);
            }
        }
        else {
            # if member type is other than union, that generate init code
            # for the member itself
            &$gen_child_init($member);
        }
    }
    $xcode .= "\tM0_POST(m0_xcode_type_invariant($item->{'name'}_xc));";
    $xcode .= "\n}\n";
    $xcode .= "#endif\n"
              if defined $item->{'attribute'}{'xc_domain'}
                 && $item->{'attribute'}{'xc_domain'} eq 'be';
    $xcode .= "\n";

    return $xcode;
}

# generate xcode init func, which init all data structures
sub gen_xc_c_init_func
{
    my @items = @_;

    my $xcode = '';

    for my $item (@items) {
        $xcode .= gen_xc_c_init_func_for($item);
    }

    $xcode .= "M0_INTERNAL void m0_xc_${xcode_id}_init(void)\n{\n";
    for my $item (@items) {
        $xcode .= "#if !defined(__KERNEL__)\n"
                  if defined $item->{'attribute'}{'xc_domain'}
                     && $item->{'attribute'}{'xc_domain'} eq 'be';
        $xcode .= "\tm0_xc_$item->{name}_struct_init();\n";
        $xcode .= "#endif\n"
                  if defined $item->{'attribute'}{'xc_domain'}
                     && $item->{'attribute'}{'xc_domain'} eq 'be';
    }
    $xcode .= "}\n\n";

    return $xcode;
}

sub gen_xc_c_fini_func
{
    return "M0_INTERNAL void m0_xc_${xcode_id}_fini(void)\n{\n}\n";
}

# generate definitions and initializations of helper type structures
sub gen_xc_c_enums
{
    my @enums = @_;

    my $xcode = "";

    for my $enum (@enums) {
        my $name           = $enum->{'name'};
        my $members_number = 0 + @{$enum->{'members'}};
        my $idx            = 0;
        my $maxlen         = -1;

        $xcode .= "const struct m0_xcode_enum_val ${name}_data[] = {\n";
        for my $val (@{$enum->{'members'}}) {
            $xcode .= <<"END_VAL"
	{ .xev_idx = $idx, .xev_name = "$val->{name}", .xev_val = $val->{init} },
END_VAL
;
            $idx = $idx + 1;
            $maxlen = max($maxlen, length($val->{name}));
        }

        $xcode .= <<"END_ENUM"
	{ .xev_idx = -1, .xev_name = "Invalid value of enum '$name'." }
};

struct m0_xcode_enum m0_xc_${name}_enum = {
	.xe_name   = "${name}",
	.xe_nr     = ${members_number},
	.xe_val    = ${name}_data,
	.xe_maxlen = $maxlen
};
END_ENUM
;
    }
    return $xcode . "\n";
}

sub gen_xc_c
{
    my ($items, $enums) = @_;

    my $xcode = gen_xc_c_header();

    $xcode .= gen_xc_c_type_struct_decl(@$items);
    $xcode .= gen_xc_c_opaque_func_decl(@$items);
    $xcode .= gen_xc_c_helper_type_struct_def(@$items);
    $xcode .= gen_xc_c_compiletime_checks(@$items);
    $xcode .= gen_xc_c_enums(@$enums);
    $xcode .= gen_xc_c_init_func(@$items);
    $xcode .= gen_xc_c_fini_func(@$items);

    return $xcode;
}

sub gen_xlist_header
{
    return <<"END_HEADER"
/* This file is automatically generated */

#ifndef __MOTR_XCODE_XLIST_H__
#define __MOTR_XCODE_XLIST_H__

END_HEADER
}

sub gen_xlist_footer
{
    return "#endif /* __MOTR_XCODE_XLIST_H__ */\n";
}

sub gen_xlist_template
{
    my $content = gen_xlist_header();

    $content .= "$xlist_block_placeholder\n";
    $content .= gen_xlist_footer();

    return $content;
}

sub gen_xlist
{
    my ($items, $enums) = @_;

    if ($header_file_path =~ m#(?:ut|it|ub)/#) {
        return "$xlist_block_start/* Skipping UT/UB/IT xcode. */\n$xlist_block_end";
    }

    # m0_xcode_type-s
    my $xcode = $xlist_block_start;
    for my $item (grep { $_->{'scope'} !~ /static/ } @$items) {
        $xcode .= "_XT($item->{name}_xc)\n";
    }
    $xcode .= "\n";

    # init functions for m0_xcode_type-s
    for my $item (@$items) {
        $xcode .= "_TI(m0_xc_$item->{name}_struct_init)\n";
    }
    $xcode .= "\n";

    # m0_xcode_enum-s
    for my $enum (@$enums) {
        $xcode .= "_EN(m0_xc_$enum->{name}_enum)\n";
    }
    $xcode .= "\n";

    # file level init-fini functions
    $xcode .= "_FI(m0_xc_${xcode_id}_init)\n";
    $xcode .= "_FF(m0_xc_${xcode_id}_fini)\n";

    $xcode .= $xlist_block_end;

    return $xcode;
}

sub xlist_lock
{
    my $lock_file_name = shift;

    open my $lock_fh, '>', $lock_file_name;
    flock $lock_fh, LOCK_EX
        or die "Cannot lock xlist file '$lock_file_name' - $!\n";
    return $lock_fh;
}

sub xlist_unlock
{
    my $lock_fh = shift;

    flock $lock_fh, LOCK_UN
        or die "Cannot unlock xlist file - $!\n";
    close $lock_fh;
    return;
}

sub update_xlist_file
{
    my ($items, $enums) = @_;

    my $blk_start       = quotemeta $xlist_block_start;
    my $blk_end         = quotemeta $xlist_block_end;
    my $blk_placeholder = quotemeta $xlist_block_placeholder;
    my $xlist           = gen_xlist($items, $enums);
    my $lock            = xlist_lock('.m0gccxml2xcode.lock');

    # if xlist file doesn't exist, create it
    if (! -e $cli_option{'list_file_name'}) {
        write_file($cli_option{'list_file_name'}, gen_xlist_template());
    }

    my $content = read_file($cli_option{'list_file_name'});

    if ($content !~ s/$blk_start .* $blk_end/$xlist/xms) {
        $content =~ s/(?=$blk_placeholder)/$xlist/xms;
    }
    write_file($cli_option{'list_file_name'}, $content);
    xlist_unlock($lock);

    return;
}

# ###############################################
#  Main
# ###############################################

sub usage
{
    pod2usage(-verbose => 0);
}

sub help
{
    pod2usage(-verbose => 1);
}

sub man
{
    pod2usage(-verbose => 2);
}

my $script_name = basename($PROGRAM_NAME);

sub process_cli_options
{
    help() if !GetOptions(
        'i|input=s'         =>  \$cli_option{'input_file_name'},
        'o|output-prefix=s' =>  \$cli_option{'output_prefix'},
        'x|xcode-path=s'    =>  \$cli_option{'xcode_path'},
        'l|list-file=s'     =>  \$cli_option{'list_file_name'},
        'castxml'           =>  \$cli_option{'castxml'},
        'h|help'            =>  \&help,
        'usage'             =>  \&usage,
        'man'               =>  \&man
    );

    croak "Error: provide either -i or -x option.\n"
          . "Please, see `$script_name --help` for more information."
        if $cli_option{'input_file_name'} eq '-'
           && !defined $cli_option{'xcode_path'};

    # if input is STDIN than also set output to STDOUT,
    # if input is *.gccxml file, than set output prefix to *
    if (!defined $cli_option{'output_prefix'}) {
        ($cli_option{'output_prefix'} = $cli_option{'input_file_name'})
            =~ s/\.gccxml$//xms;
    }

    $cli_option{'output_h_file_name'} = $cli_option{'output_prefix'} . '_xc.h';
    $cli_option{'output_c_file_name'} = $cli_option{'output_prefix'} . '_xc.c';

    # if output prefix is STDOUT, then also set output .h and .c files to STDOUT
    if ($cli_option{'output_prefix'} eq '-') {
        $cli_option{'output_h_file_name'} = '-';
        $cli_option{'output_c_file_name'} = '-';
    }
    else {
        $cli_option{'output_items_file_name'} = $cli_option{'output_prefix'} . '_xc.yml';
    }
}

sub set_global_vars
{
    if (defined $cli_option{'xcode_path'}) {
        $xcode_path = $cli_option{'xcode_path'};
    }
    else {
        my ($fn, $dir);

        # trim filename extention and path prefix
        ($fn, $dir) = fileparse($cli_option{'input_file_name'}, '.gccxml');
        $dir =~ s#/$##;

        $xcode_id = $dir . '_' . $fn;
        $xcode_id =~ s#\s+|-+|/+#_#xmsg;

        $xcode_path = $dir . '/' . $fn;
        $xcode_path =~ s#\s+|-+#_#xmsg;
    }

    # according to the motr coding style, all header files should be included
    # using full path relative to the motr/ directory; for example
    # trace.h header from motr/lib/ should be included as "lib/trace.h"
    # and not as "trace.h"; so we need to preserve a directory path after the
    # "motr/" part
    if ($cli_option{'input_file_name'} =~ m#/motr/#) {
        ($header_file_name = $cli_option{'input_file_name'})
            =~ s#^.*/motr/(.*)\.gccxml$#$1.h#xms;
    }
    else {
        # if we processing file not from motr/ source tree, then
        # just use a file name without directory path
        $header_file_name = $xcode_path . '.h';
    }

    if (defined $cli_option{'input_file_name'}) {
        ($header_file_path = $cli_option{'input_file_name'}) =~ s/\.gccxml$/.h/xms;
    }
    else {
        $header_file_path = $header_file_name;
    }

    ($include_protector_name = $header_file_path) =~ s# \s+ | -+ | / #_#xmsg;
    $include_protector_name =~ s/ \.h $//xmsg;
    $include_protector_name = '__MOTR_' . uc $include_protector_name . '_XC_H__';

    $xlist_block_start = "/* ----- BEGIN xcode from $header_file_path ----- */\n";
    $xlist_block_end   = "/* ----- END xcode from $header_file_path ----- */\n\n";
    $xlist_block_placeholder = "/* ----- NEXT BLOCK PLACEHOLDER ----- */\n";

    if (defined $cli_option{'castxml'}) {
        # with castxml we use __attribute__((annotate(...)))
        $gccxml_attr = 'annotate';
    }
    else {
        # with gccxml we use __attribute__((gccxml(...)))
        $gccxml_attr = 'gccxml';
    }
}

sub main
{
    process_cli_options();
    set_global_vars();

    # parse gccxml's output
    open my $gccxml_file, "<$cli_option{'input_file_name'}";
    my ($items, $enums) = build_item_list($gccxml_file);
    close $gccxml_file;

    # generate xcode .h file
    open my $h_file, ">$cli_option{'output_h_file_name'}";
    print {$h_file} gen_xc_h($items, $enums)
        or croak "Failed to write '$h_file' file";
    close $h_file;

    # generate xcode .c file
    open my $c_file, ">$cli_option{'output_c_file_name'}";
    print {$c_file} gen_xc_c($items, $enums)
        or croak "Failed to write '$c_file' file";
    close $c_file;

    # add records to the list file
    if (defined $cli_option{'list_file_name'}) {
        update_xlist_file($items, $enums);
    }

    # save records for further processing (used for protocol description generation)
    if (defined $cli_option{'output_items_file_name'}) {
        open my $dump_file, ">$cli_option{'output_items_file_name'}";
        print {$dump_file} Dump($items)
            or croak "Failed to write '$dump_file' file";
        close $dump_file;
    }
}

main();


__END__

=head1 NAME

m0gccxml2xcode - generates m0 xcode data from gccxml's output.

=head1 SYNOPSIS

m0gccxml2xcode -x <name> | -i <input_file> [-o <output_prefix>] [-h|--help]
[--usage] [--man]

=head1 OPTIONS

Either -x or -i option should be provided.

=over 8

=item B<-i|--input>  <file_name>

Input file name, if this option is ommited then STDIN is used instead and
"xcode-path" should be provided via -x option.

=item B<-o|--output-prefix>  <prefix>

Prefix name (all before the last dot) for the output .h and .c files.

=item B<-x|--xcode-path>  <name>

Name of generated xcode data (used in xcode init functions, include protectors,
etc.). This should be equal to the name of an input file of gccxml, but with
file extension removed. E.g. if gccxml proccess example.h, then xcode-path
should be "example". xcode-path is set automatically if -i option is provided.

=item B<-l|--list-file>  <name>

Name of a file, for which a line is added for every processed xcode type and
generated function. This file can be used to automatically initialise or
enumerate all xcode types.

=item B<--castxml>

Expect CastXML format instead of GCC-XML.

=item B<-h|--help>

Print this help summary.

=item B<--usage>

Print usage line of this summary.

=item B<--man>

Print the complete manpage.

=back

=head1 DESCRIPTION

The idea behind this script is to use some special gcc's __attribute__() with
C struct declarations in C header files to automatically generate corresponding
xcode data (see m0 xcode documentation in motr/xcode/xcode.h).

It does the same thing as ff2c generator, but instead of using pseudo-code
description of data structures, it uses C structure declarations directly from
.h files. For this purpose .h files are processed by gccxml first, and then
gccxml's output (which is in xml format) are parsed by this script into
internal format, which then used to generate xcode data.

=head2 Gccxml attributes

There is a mapping between ff2c's pseudo-language and gcc's attributes used by
this script to extract additional high-level information about C structures.

  record:      __attribute__((gccxml("xc_atype","M0_XA_RECORD")))
  sequence:    __attribute__((gccxml("xc_atype","M0_XA_SEQUENCE")))
  union:       __attribute__((gccxml("xc_atype","M0_XA_UNION")))
  [] (opaque): __attribute__((gccxml("xc_opaque","m0_package_cred_get")))
  : (tag):     __attribute__((gccxml("xc_tag","NR")))

There is a shorthand macros in xcode/xcode_attr.h: M0_XCA_XXX(). They
should be used instead of bare __attribute__((gccxml(...))):

  record:      M0_XCA_RECORD
  sequence:    M0_XCA_SEQUENCE
  union:       M0_XCA_UNION
  [] (opaque): M0_XCA_OPAQUE("m0_package_cred_get")
  : (tag):     M0_XCA_TAG("NR")

Here are some simple examples:

  struct fid {
    uint64_t        f_container;
    struct m0_cred *p_cred M0_XCA_OPAQUE("m0_package_cred_get");
    uint64_t        f_offset;
  } M0_XCA_RECORD;

  struct optfid {
     uint8_t o_flag;
     union {
        struct fid  o_fid   M0_XCA_TAG("1");
        uint32_t    o_short M0_XCA_TAG("3");
     } u;
  } M0_XCA_UNION;

This script generates xcode data only for global C structures which have
either record, sequence or union gccxml attribute. All other structures
without gccxml attribute are ignored. Structures can be defined inside other
structures, but they still have to used gccxml attribute if they need to be
processed.

=head2 Gccxml output format

Gccxml uses relatively simple output format. All information is stored in a
plain list of xml nodes of different type. Some nodes may refer to other nodes
by "type", "members" and "id" attributes.

Here is an example. Consider the following code in C:

  struct fid {
   uint64_t f_container;
   uint64_t f_offset;
  } __attribute__((gccxml("xc_atype","M0_XA_RECORD")));

Gccxml will generate xml nodes for this example like these:

  <Struct id="_366" name="fid" context="_1" mangled="3fid" demangled="fid"
          location="f2:13" file="f2" line="13" artificial="1"
          attributes="gccxml(xc_atype,M0_XA_RECORD)" size="128" align="64"
          members="_654 _655 _656 _657 _658 _659 " bases=""
  />

This xml node tells us that it describes a structure with name "fid",
attributes "gccxml(xc_atype,M0_XA_RECORD)" and members with ids "_654 _655
_656 _657 _658 _659 ".

All members are described by a <Field> tags with corresponding "id"
attributes:

  <Field id="_654" name="f_container" type="_376" offset="0" context="_366"
         access="public" location="f2:14" file="f2" line="14"
  />

  <Field id="_655" name="f_offset" type="_376" offset="64" context="_366"
         access="public" location="f2:15" file="f2" line="15"
  />

Each of the following type:

  <Typedef id="_376" name="uint64_t" type="_11" context="_1" location="f4:56"
  file="f4" line="56"/>

Which finally is:

  <FundamentalType id="_11" name="long unsigned int" size="64" align="64"/>

Note that only complete primary types have "size" attribute.

=head2 XPath

This script uses XPath queries to find required xml nodes. XPath syntax quick
reference can be found on the following web site:

  http://www.w3schools.com/xpath/xpath_syntax.asp

=head2 Internal data format

Here is an example of internal data structure used by this script to store
information extracted from gccxml, which is then used to generate xcode. It's
represented using native perl syntax, this dump is produced using Data::Dumper
module:

  [
    {
      'name' => 'optfidarray',
      'type' => 'struct',
      'scope' => '',
      'size' => '256'
      'attribute' => {
                       'xc_atype' => 'M0_XA_SEQUENCE'
                     },
      'members' => [
                     {
                       'xc_type' => '&M0_XT_U64',
                       'name' => 'ofa_nr',
                       'type' => 'uint64_t',
                       'size' => '64'
                     },
                     {
                       'xc_type' => 'optfid_xc',
                       'name' => 'ofa_data',
                       'type' => 'struct optfid*',
                       'size' => '64'
                     },
                     {
                       'xc_type' => 'fid_xc',
                       'name' => 'p_fid',
                       'type' => 'struct fid',
                       'size' => '128'
                       'members' => [
                                      {
                                        'xc_type' => '&M0_XT_U64',
                                        'name' => 'f_container',
                                        'type' => 'uint64_t',
                                        'size' => '64'
                                      },
                                      {
                                        'xc_type' => '&M0_XT_U64',
                                        'name' => 'f_offset',
                                        'type' => 'uint64_t',
                                        'size' => '64'
                                      }
                                    ]
                     }
                   ]
    }
  ];

And here is a corresponding C structure:

  struct fid {
    uint64_t f_container;
    uint64_t f_offset;
  } __attribute__((gccxml("xc_atype","M0_XA_RECORD")));

  struct optfidarray {
    uint64_t ofa_nr;
    struct optfid *ofa_data;
    struct fid p_fid;
  } __attribute__((gccxml("xc_atype","M0_XA_SEQUENCE")));

=cut

