=================
Build Environment
=================

Motr project requires sophisticated build system with many features. It also requires logical directory structure, so that modifications are done quickly and painlessly. This document aims to describes such a build environment.

***************
Definitions
***************

- build system - Autotools, Cmake, Scons, etc., that is, set of software packages, which may work together to provide the means of building complex software packages;\

- build env - build system plus project policies, such as directory structures, practices used for adding new targets, etc.

- autotools - GNU Build system, that is: GNU Automake and GNU Autoconf.

- automake - GNU Automake is a package, containing set of utilities for generating make files templates from special make target definitions, called Makefile.am. It is closely tied to autoconf (see below) and usually used along with it as part of bigger processing pipeline. As a result of automake work, Makefile.in files are generated.

- autoconf - GNU Autoconf is a package, containing set of utilities for configuring projects and generating make files from special templates, generated by automake (see above) and called Makefile.in. As a result of its work, special configure script is created and used for checking system environment. When checking is done, make files are generated, taking into account site environment, build tools and build options specifics, found in configure time.

- libtool - GNU Libtool is a package, providing portable way for building static or dynamically linked libraries by hiding platform specifics and linker/compiler options, required for building a library, in a huge, presumably portable shell script. It is usually used along with automake and autoconf.

- scons - modern, portable build system, alternative to autoconf/automake, though having all the features of them and even more. It is implemented in python and suggests, that build scripts are also written in python. This provides big deal of flexibility and potential as one can use power of python and whole bunch of existing libraries.

- cmake - one more alternative build system used for big projects. Its main difference from others is that, it generates build scripts/files, native to each platform it is used on from some very simple script, describing project checks, targets, etc. Native scripts for each platform is: makefiles for unices, MS VisualStudio project for Windows and Eclipse project for java applications.

***************
Requirements
***************

- [req.build-env.traditional] - All the traditional features of build systems, such as using timestamps optimization, build correctness, should be supported.

- [req.build-env.portability] - The same build system and source tree should be used for building Colibri on all supported platforms.

- [req.build-env.user-kernel] - The source code tree contains user space code and targets (libraries, binaries) as well as kernel space code (kernel modules).

- [req.build-env.configure-stage] - Configure stage should be present to check various system specifics, libraries, functions, headers.

- [req.build-env.configure-options] - Configure stage should support passing various configure options, such paths to other software packages to use, debug on/off, etc.

- [req.build-env.build-stage] - Build stage should be powerful enough to be able to do non-traditional build tasks, such as generating code from templates, execute shell commands, etc.

- [req.build-env.simultaneous-builds] - Simultaneous builds from the same or different nodes should be supported. Different architectures may be built simultaneously.

- [req.build-env.build-dir] - All object files, binaries and libraries, should be placed out of the source tree.

- [req.build-env.debug] - Debug on/off targets are supported and placed in different directories.

- [req.build-env.performance] - Complex project structure is supported and handled in a sophisticated way to provide as fast builds as possible.

- [req.build-env.testing] - Testing framework is built along with the project software.

- [req.build-env.git-repo] - Git repository is used for storing the project source code and build system files.

- [req.build-env.git-hooks] - Git commit hooks are set in the repository to mail code changes to the peers.

************************
Functional Specification
************************

To meet the requirements, three main parts of the build environment should be implemented:

- Configuration part. It should make sure, that required portability level is reached. It also should implement build options, such as paths to the software packages we use, debug on/off, etc;

- Generation part. Objects and binaries generation part of the build process should be implemented with focus on portability, performance and correctness. Both, configuring and generation parts should support the ability to generate binaries in a directory away of source code. This enables simultaneous builds as well as minimizes mess in source tree after the project is built;

- Repository part. All the source code should be placed in number of git repositories with all the scripts, allowing comfortable development.

Configuration Part
===================

Here is the list of what should be checked by configure part:

- Architecture, operating system, endianes - this may be required for small workarounds based on this information;

- All the tools required for building the project - compiler, linker, man generator, etc;

- Header files we use in the project. They may be different or placed in different locations;

- Libraries we link against in the project. Some functions may be placed in different libraries on different platforms. For example, pthread API functions are located in libpthread on Linux and libc on Mac OS X systems;

- Functions, which we know are not standard or may be different on some platforms (direct I/O);

- Optional things, such as debug on/off or things like whether to build or not server or client, should be moved to build/configuring options in a way like this: debug=1;

- Any software packages we need to build the project, such as db4 or Linux kernel, should be specified in the way like this: with-gss=gss-path with-linux=linux-kernel-path.

The following configuring options form configure part functionality:

+------------------------+-------------------------------------------------------------------------------------------+
|**Name**                |**Description**                                                                            |
+========================+===========================================================================================+
|debug=on/off            |Specified whether to build with or without debug information for the objects and binaries. |
+------------------------+-------------------------------------------------------------------------------------------+
|with-db4=db4-path       |    Db4 location we want to use for the metadata server.                                   |
+------------------------+-------------------------------------------------------------------------------------------+
|with-linux=linux-path   | Linux kernel location we want to use for kernel components                                |
+------------------------+-------------------------------------------------------------------------------------------+
|with-gss=gss-path       | Gss libraries location we want to use for security.                                       |
+------------------------+-------------------------------------------------------------------------------------------+
|build-dir=build-path    |  Location where the object files and binaries should be generated.                        |
+------------------------+-------------------------------------------------------------------------------------------+

Generation Part
===============

Here is the list if build part functionality:

- Options provided by configure part are taken into account, including paths, debug and optimization options;

- Support for simultaneous builds and generating binaries out of the source tree;

- Support for features like generating source code from templates (db4 fol records).

Repository Part
===============

The following functionality is provided:

- Source code is stored in a repository, supporting branches and commit hooks;

- Commit hooks are set to mail repository changes to the peers. Commit emails contain standard diff of the changes maid.

*********************
Logical Specification
*********************

Configuration Part
===================

Configuration part, in whatever build system it is implemented, check the following system specifics:

- Platform check - part of standard check in Autotools and Cmake. Very easy to figure out in Scons;

- Build tools, such as compiler, linker, etc., are usualy the part of standard configure checks for all build systems;

- Header files check - one line macro/function in all build systems;

- Libraries checks - one line macro/function in all build systems;

- Not standard functions - one line macro/function in all build systems;

- Configure options - handled differently in all build systems but still is very easy to talk much about. DLD will show examples of all the checks including configure options checks.

Generation Path
===============

Generation part is very simplistic for all of the build systems described. One just specifies what targets needed: binaries, libraries, etc. The only exception is that, we may possibly need handling for not standard source files, such as fol template, to generate fol tables for db4.

Repository Path
================

So far this is the repository storing different logical parts of the Motr source tree:

+------------------------+-------------------------------------------------------------------------------------------+
|**Name**                |**Description**                                                                            |
+========================+===========================================================================================+
|cortx-motr              | git clone --recursive git@github.com:Seagate/cortx-motr.git                               |
|                        |                                                                                           |
+------------------------+-------------------------------------------------------------------------------------------+

cortx-motr has the following structures.

- doc - documentation such as installation guide, APIs description;

- man - standard manual pages for binaries, config files (if any), etc;

- addb - addb module;

- ctdb - ctdb module;

- fol - fol module;

- nrs - nrs module;

- sns - sns module;

- net - networking code;

- lib - common code for all the modules;

- include - all motr include files;


Every sub directory, which contains something to build (code, man pages, etc), should have own build script. This build script builds only thing related to its directory. This is worth to mention, as some build systems allow to do everything from the project root directory. This would make root build script huge and even the best build system in the world will not save it from becoming mess very quickly.

It is important to configure the project before building. This allows build system to adopt to different versions of libraries installed, find compiler and linker paths, etc., giving the ability to be as portable as possible.

Conformance
===============

- [req.build-env.traditional] - Covered with configuration part of the build environment.

- [req.build-env.portability] - Portability requirement is covered by build system used for the build environment. Some of them are more better in this: scons uses python or generates native IDE projects, cmake generates native IDE projects on Windows and uses make on Unix. Autotools is less convenient as it has more difficulties to build things on Windows.

- [req.build-env.user-kernel] - Configure stage allows to specify linux kernel location. This theoretically allows to build kernel components in same tree with user space components, according kernel manuals on how to build kernel components out of kernel source tree.

Issue is that, kernel is built using make and its out-of-tree building is based on make. One needs to create specially formatted make file to be able to build kernel modules. This means that scons cannot be used for building kernel modules unless somebody adds scons support to linux kernel. Or alternatively we can call make from scons.

That said, to cover this requirement we need to use Autotools (make based build system) and this contradicts to other requirements (portability). This may end up with attempt to use two build systems in parallel, which leads to more complexity and bugs.

- [req.build-env.configure-stage] - All build systems have powerful configure functionality, in which they check all the system specifics, such as platform, endianess, headers, etc.

- [req.build-env.configure-options] - All build systems, which could be used by Colibri build environment, may easily pass configure options down to the generation part.

- [req.build-env.build-stage] - All build systems have build stage, which is usually follows after configure stage and builds objects, using configure options and findings.

- [req.build-env.simultaneous-builds] - Most of build systems can do simultaneous builds (parallel builds in Autotools manual). Still, scons is doing this the way exactly we need, that is, generates build tree in specified location without needs to do something more by hands. Latter is required for Autotools and Cmake. They imply, that one does this: mkdir build; cd build; configure ... && make.

- [req.build-env.build-dir] - Scons build system allows easily to specify the directory all the binaries should be generated in. Others do not allow to do it simple-portable way.

- [req.build-env.debug] - Just one of options. May be handled easily by all build systems.

- [req.build-env.performance] - Scons provides slightly more flexibility here due to rich set of "deciders" - functions to check if source file has changed since last build. It also may be much faster than autotools because of caches and different way of building the sources (no need to chdir to every single directory all the time).

- [req.build-env.testing] - We just create tests directory, place tests code there and build it all along with the rest of the package.

Dependencies
===============

- configure-stage

  - scons

    - python

  - autotools

    - bash

      - cygwin (Windows)

  - cmake

    - bash

      - cygwin (Windows)


    - cmake interpreter

- build-stage

  - scons

    - python

    - make

    - gcc, linker

  - autotools

    - make

    - gcc, linker

  - cmake

    - native build tool

- git

  - server side hooks
  
Refinement
==========

Scons Specifics
----------------

- Scons scripts run into two phases:

  - Preparation. All the code in script is executed. All targets like Program, Library or Object are added to special construction list;

  - Construction. Construction list, formed in previous stage, is processed to build all the targets specified. Everything that builds with custom builder, will be also built in construction phase. This means, that custom builders are better not used for generating source code from templates, because generation will happen in construction phase, where the source code has to be already generated.

- There is possibility to define custom Builder (builds non-standard input files) and Scanner (parses non-standard input files).

Linking against non installed libraries
---------------------------------------

One more thing to work out deeply in the DLD is linking against not installed shared libraries. We may potentially have this need to link against our custom db-4 version. Issue is that, linking against such libraries means that they cannot be found by dynamic linker and as such, cannot be used without additional hands work like setting up LD_LIBRARY_PATH. Worth to say, that most of build system rely and recommend to link against installed libraries.

This all raises couple of rather important questions, which should be discussed in the DLD:

- Do we really need to link against not-installed db-4 libraries or we better install them?

- If we do install them, should we rename them to not conflict with already installed libraries in the system or should we maintain our custom db-4 APIs the way that it is still usable for the rest of system tools?

- If we do not install our custom db-4, is it good style to link against it statically?

Building Kernel Modules
------------------------

There is an issue with building kernel modules using scons. As kernel is make based, one needs to generate specially formatted makefiles and call make from scons script. This is not looking very well. We need to think on how to solve this.

There are three ways of solving this:

- Generate makefiles and call make from scons;

- Reject scons completely and use Autotools (contradicts to portability use cases);

- Add scons support to linux kernel (lots of effort and out of our main focus).

***************
State
***************

Events and Transitions
=========================

Events:

- debug on/off is specified;

- with-db4 option is specified;

- architecture is detected;

- build dir is specified;

- build failure

States:

- configuring;

- generation

State Invariants
=================

Whole the build environment changes its state from configuring to generating. In scons this is done seamlessly, without user attention. Still these two states are separated in time.

Concurrency Control
===================

- [concur.simultaneous-build.different-nodes] - Separate build directories are used for maintaining consistency. Dir names are formed using node name and architecture name. In correctly configured network, this ensures correct simultaneous build;

- [concur.simultaneous-build.same-node] - Separate build directories are used for maintaining consistency. Directory names are specified by user, running the build command.
