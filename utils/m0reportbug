#!/usr/bin/env bash
#
# Copyright (c) 2020 Seagate Technology LLC and/or its Affiliates
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# For any questions about this software or licensing,
# please email opensource@seagate.com or cortx-questions@seagate.com.
#

set -eu
# set -x
export PS4='+ [${FUNCNAME[0]:+${FUNCNAME[0]}:}${LINENO}] '

### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### When modifying this script, please increment VERSION and add new
### entry to the 'History' section below.
### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
VERSION=0.53

OUT_DATA_DIR=m0reportbug-data
OUT_CORES_DIR=m0reportbug-cores
OUT_TRACES_DIR=m0reportbug-traces
REPORT=m0reportbug.txt # the file is created in $OUT_DATA_DIR/
M0TRACES_MAX=20 # how many most recently modified m0trace files to collect
M0TRACES_M0D_MAX=2 # additionally, collect that many m0trace files from each
                   # $IN_DIR/m0d-* directory
NR_BOOTS_MAX=10 # how many boots to query systemd journal for
ADDB_TAIL=100000 # limit each m0addb2dump output file to that many lines
CRASH_AGE_MAX=3 # maximal age (days) of vmcore-dmesg.txt files to be collected
STAGE_TIME_LIMIT=10 # seconds; if a stage runs longer, show its duration
DEFAULT_INPUT_DIRS_GLOB='/var/motr*'
IN_DIR=
CORE_DIRS=("/var/crash/" "/var/log/crash/") # path from where m0reportbug will collect cores
RECOVERY_SCRIPT_DIR=/opt/seagate/cortx/motr/libexec    # dir containing recovery traces and scripts
RECOVERY_LOG_DIR=/var/log/seagate/motr/datarecovery    # dir containing recovery log/logs
LIVE_CORE_DIR=/var/log/seagate/motr
M0TR_M0D_TRACE_DIR=/var/log/seagate/motr/trace

readonly START_DIR=$PWD

umask 0002
export LC_ALL=C

_xz() { xz --threads=0 "$@"; }

main() {
    local stages=(
        # NB: mark functions that use $IN_DIR with '^' prefix
        probes
        ^misc_files
        backtraces_live
        coredump_live     # must precede `backtraces_core' stage
        ^backtraces_cores # must precede `binaries' stage
        binaries # will be skipped unless COLLECT_BINARIES_P=1
        ^m0traces
        ^addb # Should go after `m0traces' stage (m0addb2dump creates new
              # m0traces, which we don't want to collect).
       ^addb-files
        systemd_journal
        sysrq_info
    )

    optparse "$@"

    [ `id -u` -eq 0 ] || die 'Must be run by superuser'

    ## Clean old m0reportbug output before generating new.
    rm -rf {$OUT_DATA_DIR,$OUT_CORES_DIR,$OUT_TRACES_DIR}{,.tar.xz}

    mkdir $OUT_DATA_DIR
    pushd $OUT_DATA_DIR >/dev/null

    echo m0reportbug $VERSION >$REPORT
    echo PWD=$START_DIR >>$REPORT
    echo "INPUT_DIRS=(${INPUT_DIRS[@]})" >>$REPORT

    local stage
    for stage in "${stages[@]}"; do
        local uses_IN_DIR=false
        if [[ $stage != ${stage#^} ]]; then
            uses_IN_DIR=true
            stage=${stage#^}
        fi

        case $stage in
            addb) [ ${COLLECT_ADDB_P:-0} -eq 1 ] || continue;;
            addb-files) [ ${SKIP_ADDB_FILE_P:-0} -eq 1 ] && continue;;
            binaries) [ ${COLLECT_BINARIES_P:-0} -eq 1 ] || continue;;
        esac

        for IN_DIR in ${INPUT_DIRS[@]}; do
            [[ -d $IN_DIR ]] || {
                warn "$IN_DIR: no such directory"
                continue
            }
            [[ -L $IN_DIR ]] && {
                # As per our design, after failover softlink /var/motr is
                # created to points /var/motr{1-2}, and since our INPUT_DIR
                # is globe pattern (/var/motr*) we end up collecting m0traces
                # and cores twice unnecessary, hence skipped data collection
                # if IN_DIR is a soft link.
                continue
            }
            export IN_DIR=$(readlink -f $IN_DIR)

            local label=$stage
            if ((${#INPUT_DIRS[@]} > 1)) && $uses_IN_DIR; then
                label+=" ($IN_DIR)"
            fi

            echo -n "$label... " >&2
            section "[$label]"
            local t=$(date +%s)
            $stage
            echo "OK$(_time $t)" >&2

            # Stages that don't use $IN_DIR (e.g., probes, systemd_journal)
            # should only be executed once.
            $uses_IN_DIR || break
        done
    done >>$REPORT

    # Collects compressed core generated in /var/crash and /var/log/crash
    for IN_DIR in  ${CORE_DIRS[@]}; do 
        [[ -d $IN_DIR ]] || {
                warn "$IN_DIR: no such directory"
                continue
        }
        local label="backtraces_core $IN_DIR"
        echo -n "$label... " >&2
        section "[$label]" >>$REPORT
        local t=$(date +%s)
        backtraces_cores >>$REPORT
        echo "OK$(_time $t)" >&2
    done

    # Collects live/compressed core generated in /var/crash
    if [ -d $LIVE_CORE_DIR ]; then
        IN_DIR=${LIVE_CORE_DIR}
        local label="backtraces_core $IN_DIR"
        echo -n "$label... " >&2
        section "[$label]" >>$REPORT
        local t=$(date +%s)
        backtraces_cores >>$REPORT
        # Remove live-cores generated in LIVE_CORE_DIR
        rm -rf $LIVE_CORE_DIR/core-live.*
        echo "OK$(_time $t)" >&2
    else
        warn "$LIVE_CORE_DIR: no such directory"
    fi

    # Collects traces for beck run
    if [ -d $RECOVERY_SCRIPT_DIR ]; then
        IN_DIR=${RECOVERY_SCRIPT_DIR}
        local label="m0traces $IN_DIR"
        echo -n "$label... " >&2
        section "[$label]" >>$REPORT
        local t=$(date +%s)
        m0traces >>$REPORT
        echo "OK$(_time $t)" >&2
    else
        warn "$RECOVERY_SCRIPT_DIR: no such directory"
    fi

    # Collects traces of m0d process(confd, ios) only
    M0TR_M0D_TRACE_DIR=$(cat /etc/sysconfig/motr  | grep "^MOTR_M0D_TRACE_DIR" | cut -d '=' -f2)
    M0D_TRACE_DIR="${M0TR_M0D_TRACE_DIR%\'}"
    M0D_TRACE_DIR="${M0D_TRACE_DIR#\'}"

    if [[ -d "$M0D_TRACE_DIR" ]]; then
        IN_DIR=${M0D_TRACE_DIR}
        local label="m0traces $IN_DIR"
        echo -n "$label... " >&2
        section "[$label]" >>$REPORT
        local t=$(date +%s)
        m0traces >>$REPORT
        echo "OK$(_time $t)" >&2
    else
        warn "$M0TR_M0D_TRACE_DIR: no such directory"
    fi

    # Collects addb record files for process(confd, ios and s3server)
    ADDB_RECORD_DIR=$(cat /etc/sysconfig/motr  | grep "^MOTR_M0D_ADDB_STOB_DIR" | cut -d '=' -f2)
    ADDB_DIR="${ADDB_RECORD_DIR%\'}"
    ADDB_DIR="${ADDB_DIR#\'}"

    if [[ -d "$ADDB_DIR" ]]; then
        IN_DIR=${ADDB_DIR}
        local label="addb-files $IN_DIR"
        echo -n "$label... " >&2
        section "[$label]" >>$REPORT
        local t=$(date +%s)
        addb-files >>$REPORT
        echo "OK$(_time $t)" >&2
    else
        warn "$ADDB_DIR: no such directory"
    fi

    popd >/dev/null
    # Collect rpm-update-logs
    if [ -f /var/log/motr-rpm-conf-update.log ]; then
        cp -pv /var/log/motr-rpm-conf-update.log $OUT_DATA_DIR/
    fi

    tar --remove-files -cJf $OUT_DATA_DIR{.tar.xz,}
    local files=$OUT_DATA_DIR.tar.xz
    for t in $OUT_CORES_DIR $OUT_TRACES_DIR; do
        if [ -d $t ]; then
            tar --remove-files -cJf $t{.tar.xz,}
            files+=":$t.tar.xz"
        fi
    done
    if echo $files | grep -q :; then
        echo 'Please attach these files to the bug report:' >&2
        echo $files | sed -e 's/^/  /' -e 's/:/\n  /g' >&2
    else
        echo "Please attach $files to the bug report." >&2
    fi
}

probes() {
    local p
    local probes=(
        'date -u --rfc-3339=seconds'
        'hostname'
        'uptime'
        'm0version'
        'm0d -v'
        'rpm -qi cortx-motr'
        'rpm -qi cortx-hare'
        'rpm -qR cortx-motr'
        'rpm -qR cortx-hare'
        'uname -a'
        'cat /proc/cmdline'
        'cat /proc/cpuinfo'
        'cat /proc/diskstats'
        'cat /proc/interrupts'
        'cat /proc/mdstat'
        'cat /proc/meminfo'
        'cat /proc/partitions'
        'cat /proc/vmstat'
        'free'
        'mount'
        ## - XXX Querying m0t1fs free space will hang if there is m0d failure.
        ##   Skip m0t1fs until this issue is resolved.
        ## - Querying other network filesystems may also hang. Exclude `nfs'
        ##   to be on the safe side.
        ## - Disable it entirely because even with -x m0t1fs it calls a syscall
        ##   which calls m0t1fs code. Will be re-enabled when m0t1fs locking
        ##   is fixed.
        # 'df -h -x m0t1fs -x nfs'
        'df -h'
        'lspci'
        'gcc --version'
        'ip addr'
        'ip -s link'
        'cat /etc/modprobe.d/lnet.conf'
        'cat /sys/kernel/debug/motr/trace/stat'
        'lsmod'
        'ps -e f'
        'ps auxH'
        'ls /dev/disk/by-*'
        'dmesg'
        'systemctl status -l'
        'systemctl status -l motr-kernel'
        'lctl dk'
        'hctl status'
        'list_input_dirs'
        'lsblk'
        'lvdisplay'
        'vgdisplay'
        'pvdisplay'
    )
    for p in "${probes[@]}"; do
        section $p
        $p 2>&1 || true
    done
}

list_input_dirs() {
    local d
    for d in ${INPUT_DIRS[@]}; do
        find $(readlink -f $d) -exec ls -ld {} +
    done
}

_kdump_files() {
    local kdump_path=

    if [ -f /etc/kdump.conf ]; then
        kdump_path=$(sed -n 's/^path \+//p' /etc/kdump.conf)
    fi
    [ -n "$kdump_path" -a -d "$kdump_path" ] || kdump_path=/var/crash
    if [ -d "$kdump_path" ]; then
        find $kdump_path -type f -name vmcore-dmesg.txt -ctime -$CRASH_AGE_MAX
    fi
}

misc_files() {
    local outdir path f

    (outdir=$(readlink -f .)/misc
     cd "$IN_DIR"
     find . -type f \( -name \*.log -o -name \*.xc \) | cut -c3- |
         while read path; do
             mkdir -p $outdir/$(dirname $path)
             cp -p $path $outdir/$path
             echo $path
         done
     )

    outdir=$(readlink -f .)/root-misc
    {
        find /etc/motr/ -type f 2>/dev/null || true
        find /etc/sysconfig/ -maxdepth 1 -type f \
             \( -name motr\* -o -name m0d\* -o -name m0t1fs\* \) |
            while read f; do
                echo $f
                grep '^MOTR_CONF_XC=' $f | cut -d\' -f2 # may produce duplicates
            done | sort -u
    } | while read path; do
        [ "$path" != "${path#/}" ] || {
            warn "${FUNCNAME[0]}: Absolute path expected: $path"
            continue
        }
        [ -f $path ] || {
            echo "$path: No such file"
            continue
        }
        mkdir -p $outdir$(dirname $path)
        cp -p $path $outdir$path
        echo $path
    done

    if [ -d ${RECOVERY_LOG_DIR} ]; then
        mkdir -p $outdir/recovery
        cp ${RECOVERY_LOG_DIR}/motr_data_recovery* $outdir/recovery/
    fi

}

die() { echo "**ERROR** $@" >&2; exit 1; }
warn() { echo "*WARNING* $@" >&2; }

section() { echo "----- $@ -----"; }

_time() {
    local start=$1
    local limit=${STAGE_TIME_LIMIT:-0}
    local t=$(($(date +%s) - start))

    if [ $limit -ne 0 -a $t -gt $limit ]; then
        printf ' (%um%us)' $((t / 60)) $((t % 60))
    fi
}

program_from_core() {
    local core=$1
    if [ ! -s $core ]; then
        warn "$(readlink -f $core) is empty"
        return
    fi
    local prog=$(file $core | sed -En "s/.*, from '([^ ']+).*/\1/p")
    if [ -n "$prog" ]; then
        ## $ file /var/motr/ios1/core.1271
        ## /var/motr/ios1/core.1271: ELF 64-bit LSB core file x86-64, version 1 (SYSV), SVR4-style, from 'm0d -e lnet:10.22.192.32@tcp:12345:42:401 -f <0x7200000000000001:4> -T ad -D db'
        :
    else
        ## $ file /var/motr/m0ut/ut-sandbox/core.4239
        ## /var/motr/m0ut/ut-sandbox/core.4239: ELF 64-bit LSB core file x86-64, version 1 (SYSV), too many program header sections (16647)
        prog=$(gdb -batch -nx -ex "core $core" 2>/dev/null |
                   sed -En "s/^Core was generated by \`([^ ']+).*/\\1/p")
    fi

    if [[ -z "$prog" ]]; then
        warn "Cannot deduce program name from \`$core'"
        {
            echo -n '[DEBUG] '
            file $core
            gdb -batch -nx -ex "core $core" 2>/dev/null || true
        } >&2
    fi
    basename "$prog"  # quotes are necessary
}

### Since $0 may be a relative path (e.g., 'utils/m0reportbug'),
### we might not be able to canonicalize it after cd-ing to $OUT_DATA_DIR.
PROG=$(readlink -f $0)

_path_rpm() {
    [ $# -eq 1 ] || die "Usage: ${FUNCNAME[0]} <name>"
    local name=$1

    case $name in
        m0d|m0trace|m0tracedump) echo "/usr/bin/$name";;
        m0mkfs) echo "/usr/sbin/$name";;
        m0addb2dump) echo "/usr/sbin/$name";;
        m0beck|m0betool) echo "/usr/sbin/$name";;
        libmotr.so) readlink -f /usr/lib64/libmotr.so;;
        m0tr.ko) echo "/lib/modules/$(uname -r)/kernel/fs/motr/$name";;
        m0ham|lt-m0ham) echo "/usr/sbin/$name";;
        m0ut|lt-m0ut)
            ## Provided by motr-tests-ut-*.rpm (optional).
            echo "?/usr/bin/${name#lt-}";;
        libmotr-ut.so|libmotr-xcode-ff2c.so)
            ## Provided by motr-devel-*.rpm (optional).
            echo "?/usr/lib64/$name.0.0.0";;
        libgalois.so) echo "/usr/lib64/libgalois-0.1.so";;
        python) type -p python;;
        *) die "${FUNCNAME[0]}: Unsupported argument: $name";;
    esac
}

_path_src() {
    [ $# -eq 2 -a -z "${2%.libs/}" ] ||
        die "Usage: ${FUNCNAME[0]}: <name> [.libs/]"
    local name=$1
    local subdir="$2"

    local src="$(echo $PROG | sed -n 's:/utils/m0reportbug$::p')"
    [ -n "$src" ] || die "${FUNCNAME[0]}: Impossible happened"

    case $name in
        m0d|lt-m0d) echo "$src/motr/${subdir}$name";;
        m0mkfs|lt-m0mkfs) echo "$src/utils/mkfs/${subdir}$name";;
        m0trace|m0tracedump)
            [ -z "$subdir" ] || die "${FUNCNAME[0]}: Unexpected argument"
            echo "$src/utils/trace/$name";;
        m0addb2dump)
            [ -z "$subdir" ] || die "${FUNCNAME[0]}: Unexpected argument"
            echo "$src/addb2/$name";;
        libmotr.so) readlink -f "$src/motr/.libs/libmotr.so";;
        m0tr.ko) echo "$src/$name";;
        m0ham|lt-m0ham) echo "$src/ha/.libs/$name";;
        m0ut|lt-m0ut) echo "$src/ut/.libs/$name";;
        m0beck|m0betool) echo "$src/be/tool/.libs/$name";;
        libmotr-ut.so) echo "$src/ut/.libs/$name.0.0.0";;
        libmotr-xcode-ff2c.so) echo "$src/xcode/ff2c/.libs/$name.0.0.0";;
        libgalois.so)
            echo "$src/extra-libs/galois/src/.libs//libgalois-0.1.so";;
        lt-m0rwlock) echo "$src/rm/st/.libs/lt-m0rwlock";;
        python) type -p python;;
        *) die "${FUNCNAME[0]}: Unsupported argument: $name";;
    esac
}

path() {
    [ $# -ge 1 -a -n "$1" -a -z "${2:-}" -o "${2:-}" = binary ] ||
        die "Usage: ${FUNCNAME[0]} <name> [binary]"
    local name=$1
    local subdir="${2:+.libs/}"
    local result
    local optional=0

    if [ "$(dirname $PROG)" = '/usr/sbin' ]; then
        result=$(_path_rpm $name) # installed from rpm
    elif [ -n "$(echo $PROG | sed -n 's:/utils/m0reportbug$::p')" ]; then
        result=$(_path_src $name "$subdir") # running from sources
    else
        # Apparently `m0reportbug' is not running sources. We assume that
        # executables and libraries were installed from rpm (we wouldn't
        # know where to look for them if they weren't), and that
        # `m0reportbug' was copied to some non-/usr/sbin directory
        # (for testing purpose or whatever).
        result=$(_path_rpm $name)
    fi
    [ "${result#\?}" = "$result" ] || local optional=1 # file may be missing
    result="${result#\?}"

    if [ -z "$result" ]; then
        warn "${FUNCNAME[0]}: Unable to find $name"
    elif ! [ -a "$result" ]; then
        [ $optional -eq 1 ] || warn "${FUNCNAME[0]}: $result: No such file"
    elif [ "${2:-}" = binary -a \
           "$(file -bi $result | cut -d= -f2)" != binary ]; then
        warn "${FUNCNAME[0]}: $name is not a binary file"
    else
        echo $result
    fi
}

## `m0version` should work even when `m0d` is not in PATH.
m0version() { $(path m0d) -v; }

GDB=$(which gdb 2>/dev/null || true)

gdb_bt() {
    [ -n "$GDB" ] || die "${FUNCNAME[0]} cannot be used"
    [ $# -eq 2 ] || die "Usage: ${FUNCNAME[0]} <prog> {<core>|<pid>}"

    [ -n "$1" ] || return 0 # do nothing if `prog' argument is empty
    local libdir=$(dirname "$(path libmotr.so)")
    {
        cat <<EOF
echo "set solib-search-path .:$libdir"
set pagination off
p "### bt"
bt
p "### thread apply all bt"
thread apply all bt
p "### thread apply all bt full"
thread apply all bt full
p "### info sharedlibrary"
info sharedlibrary
EOF
    } | $GDB -nx "$@" 2>&1 || true
    echo
}

backtraces_live() {
    local pid task

    pgrep '\<(lt-)?m0|\<(dd|fio|mount)\>' | while read pid; do
        local args="$(ps h -o args $pid)"
        [ -n "$args" ] || continue # the process may be gone
        local prog=$(echo $args | cut -d' ' -f1)

        section /proc/$pid/stack
        echo args: $args
        cat /proc/$pid/stack 2>&1 || true # the process may be gone

        { ls /proc/$pid/task 2>&1 || true; } | while read task; do
            section /proc/$pid/task/$task/stack
            cat /proc/$pid/task/$task/stack 2>&1 || true
        done

        [ "${prog#[}" = "$prog" ] || continue # skip kernel threads
        case $(basename $prog) in
            bash|sh|dd|fio) # skip these as well
                continue;;
        esac

        section $pid $(basename $prog)
        [ -z "$GDB" ] || gdb_bt $prog $pid
    done
}

coredump_live() {
    mkdir -p $LIVE_CORE_DIR
    plt=$(systemd-detect-virt) || :
    if [[ $plt == "kvm" ]]; then
        warn "## live core are not collected on $plt ##"
        return
    fi
    which gcore &>/dev/null || {
        warn "${FUNCNAME[0]} cannot be used"
        return
    }
    pgrep '\<(lt-)?m0d|\<(dd|fio|mount)\>' | while read pid; do
        local pname=$(ps -o comm= -p $pid)
        section live dumps ${pname}.{$pid}
        gcore -o "${LIVE_CORE_DIR}/core-live.$pname" $pid &>/dev/null
    done
}

_coredump() {
    [ $# -eq 2 ] || die "Usage: ${FUNCNAME[0]} <inpath> <outdir>"
    local core=$1
    local outdir=$2

    mkdir -p $outdir/$(dirname $core)
    ls -sh $core # print size
    _xz -c $core | {
        local err
        ## Write no more than 64 MB.
        if ! err=$(dd ibs=8k count=8k of=$outdir/$core.xz 2>&1); then
            echo $err
            return
        fi
        ## Is there anything left in the input stream?
        if [ $(dd bs=1 count=1 2>/dev/null | wc -c) -gt 0 ]; then
            echo "Skipping $outdir/$core: compressed file is too large"
            rm $outdir/$core.xz
        else
            touch -r $core $outdir/$core.xz
        fi
    }
}

backtraces_cores() {
    local outdir=$START_DIR/$OUT_CORES_DIR
    local core
    local prog

    ## Print backtraces.
    if [ -n "$GDB" ]; then
        find "$IN_DIR" -type f -name core\* ! \( -name core\*.xz  -o -name core\*.gz \)| while read core; do
            prog=$(program_from_core $core)
            # print backtrace only of motr binaries.
            # i.e lt-m0d, m0d, lt-m0kv, m0crate etc.
            if [[ -n "$prog" && $prog =~ ^(lt-|)m0[a-z]+ ]]; then
                section $core
                gdb_bt "$(path $prog binary)" $core
            fi
        done
    fi

    ## Pack core dumps.
    section core dumps $IN_DIR
    (find "$IN_DIR" -type f -name core\* ! \( -name core\*.xz -o -name core\*.gz \) | while read core; do
         prog=$(program_from_core $core)
         # collects core only of motr programs.
         if [[ -n "$prog" && $prog =~ ^(lt-|)m0[a-z]+ ]]; then
             _coredump $core $outdir
         fi
     done)

    # Copy the readily available compressed core.*.xz
    [[ -d $outdir/$IN_DIR ]] || mkdir -p "$outdir/$IN_DIR"
    find "$IN_DIR" -type f \( -name core\*.xz -o -name core\*.gz \) | while read core; do
        # Capture compressed core file only of motr from  IN_DIR
        # i.e. core.m0d.12345.xz/gz, core.0.lt-m0kv.12345.xz/gz
        local fname=$(basename $core)
        if [[ -n "$fname" && $fname =~ ^core(.[0-9]+|).(lt-|)m0[a-z]*.[0-9]+.(xz|gz) ]]; then
            cp $core $outdir/$IN_DIR/
        fi
    done

    if [ -d $outdir ] && ! rmdir $outdir 2>/dev/null; then
        ## Core dumps were collected. We need to collect binaries.
        COLLECT_BINARIES_P=1
    fi
}

binaries() {
    local outdir=$START_DIR/$OUT_CORES_DIR/binaries
    local -r libs=(
        libmotr.so
        libmotr-xcode-ff2c.so
        libmotr-ut.so
        libgalois.so
    )
    local f s

    mkdir -p $outdir
    ## Note, that we intentionally skip `m0tr.ko' as it's too big (42M).
    for f in m0mkfs m0d m0ham m0ut m0beck m0betool ${libs[@]}; do
        s=$(path $f binary)
        if [ -n "$s" ]; then
            ## Strip `.0.0' suffix when copying.
            f=$(basename $s)
            cp -pv $s $outdir/${f%.0.0}
            ## RATIONALE: Shared libraries, required by a binary, have
            ## `.0.0' suffix stripped.
            ##
            ##     $ objdump -p lt-m0ut | awk '/NEEDED/ {print $2}' | head -2
            ##     libmotr-ut.so.0
            ##     libmotr-xcode-ff2c.so.0
            ##
            ## By stripping `.0.0' suffixes, we let developers load
            ## shared library symbol files by executing
            ## `set solib-search-path m0reportbug-cores/binaries' GDB command.
            ## If the full name of shared library was preserved (e.g.,
            ## `libmotr-ut.so.0.0.0'), gdb would not be able to find this
            ## library.
        fi
    done
    ## copy recovery scripts
    if [ -f ${RECOVERY_SCRIPT_DIR}/motr_data_recovery.sh ]; then
        outdir=$START_DIR/$OUT_CORES_DIR/scripts
        mkdir -p $outdir
        cp -pv ${RECOVERY_SCRIPT_DIR}/motr_data_recovery.sh $outdir
    fi
}

_get_jc_cursor() {
    journalctl -n0 --show-cursor | awk '/cursor/ {print $NF}'
}

sysrq_info() {
    local -A sysrq_cmd=(
        [w]='show-blocked-tasks'
        [l]='show-backtrace-all-active-cpus'
        [t]='show-task-states'
        [m]='show-memory-usage'
    )
    local old_sysrq=$(sysctl --values kernel.sysrq)

    # unmask all sysrq functions
    sysctl --quiet --write kernel.sysrq=1

    for c in ${!sysrq_cmd[@]} ; do
        local cursor=$(_get_jc_cursor)
        echo $c > /proc/sysrq-trigger
        section "sysrq ${sysrq_cmd[$c]}"
        journalctl --no-pager --dmesg --after-cursor="$cursor"
    done

    # restore original sysrq functions
    if [[ -n "$old_sysrq" ]] ; then
        sysctl --quiet --write kernel.sysrq=$old_sysrq || true
    fi
}

last_modified() {
    local limit="$1"

    if [ -z "$limit" ]; then
        cat
    else
        xargs -r stat -c '%Y %n' | sort -nr -k1,1 | head -n $limit |
            cut -d' ' -f2-
    fi
}

_tracedump() {
    [ $# -eq 2 ] || die "Usage: ${FUNCNAME[0]} <inpath> <outdir>"
    local path=$1
    local outdir=$2
    local m0tracedump=$(path m0tracedump)

    path=$(readlink -f $path)  # convert to absolute path
    mkdir -p $outdir$(dirname $path)
    ##
    ## Disable stderr output to suppress these messages:
    ##
    ## > lt-m0tracedump: Warning: skipping non-existing trace
    ## > descriptor 0x7f977d0bdb00 (orig 0x7ff6ad5c9b00)
    $m0tracedump -s -i $path 2>/dev/null | _xz >$outdir$path.yaml.xz
    touch -r $path $outdir$path.yaml.xz
    echo $path.yaml.xz
}

m0traces() {
    local path dir
    local m0trace=$(path m0trace)
    local m0tracedump=$(path m0tracedump)
    local outdir=$START_DIR/$OUT_TRACES_DIR

    [ -x "$m0tracedump" ] || return 0 # don't fail

    (cd "$IN_DIR"
     {
         find . -maxdepth 1 -type f -name m0trace.\* | last_modified "${M0TRACES_MAX:-}"
         find . -maxdepth 1 -type d -name m0d-\* | while read dir; do
             find $dir -type f -name m0trace.\* |
                 last_modified "${M0TRACES_M0D_MAX:-}"
         done
     } | cut -c3- | sort -u | while read path; do
         _tracedump $path $outdir
     done)
}

addb() {
    local outdir=addb
    local dir path

    local m0addb2dump=$(path m0addb2dump)
    (outdir=$(readlink -f .)/$outdir
     cd "$IN_DIR"
     for pid in `pgrep m0d`; do
         find . -type d -name addb-stobs-$pid | cut -c3- | while read dir; do
	    find $dir/o -type f -name \*:2 | while read path; do
               path=$(readlink -f $path) # convert to absolute path
               mkdir -p $outdir$(dirname $path)
               ##
               ## Note that m0addb2dump needs absolute path.
               ## If relative path is provided, m0addb2dump fails:
               ##
               ## > lt-m0addb2dump: Cannot create stob: -2: No such file
               ## > or directory
               $m0addb2dump $path | tail -$ADDB_TAIL | _xz >$outdir$path.xz
               touch -r $path $outdir$path.xz
               echo $path.xz
            done
         done
     done)

}

addb-files() {
    echo "addb-files : $IN_DIR"
    mkdir -p addb_files/$IN_DIR

    for i in $(pgrep s3server) ; do
        local file_path=$(ls ${IN_DIR}/../s3server-*/addb_*/o/100000000000000\:2 2>/dev/null | grep $i)
        if [ $? -eq 0 ] && [ -f "$file_path" ]; then
            echo $file_path
            cat $file_path | _xz > addb_files/$IN_DIR/s3_addb_${i}.xz;
       fi
    done

    for pid in `pgrep m0d`; do
        for file_path in $(find ${IN_DIR}/m0d-*/addb-stobs-$pid/o  -name "100000000000000:2" 2>/dev/null); do
            if [ -f "$file_path" ]; then
                fid=$(echo $file_path | cut -d '/' -f7 | cut -d '-' -f2)
                cat $file_path | _xz > addb_files/$IN_DIR/m0d_addb__${fid}.xz
            fi
        done
    done
}

systemd_journal() {
    local nr_boots=$(journalctl --list-boot | wc -l)
    if ((nr_boots > NR_BOOTS_MAX)); then
        nr_boots=$NR_BOOTS_MAX
    fi
    local outdir=$(readlink -f .)
    for ((i = 0; i < nr_boots; ++i)); do
        journalctl -b -$i 2>>$REPORT | _xz >$outdir/systemd-journal_$i.xz
    done

    if ((nr_boots == 0)); then
        journalctl 2>>$REPORT | _xz > $outdir/systemd-journal.xz
    fi
}

usage() {
    cat <<EOF
Usage: ${0##*/} [OPTION] [INPUT_DIR]...
Gather forensic data, needed to investigate Motr issues, from INPUT_DIR(s)
and their subdirectories.

Options:
    -h, --help         Show this help and exit.
    --addb             Collect ADDB data.
    --skip-addb-files  skip collection of ADDB files
    -b, --binaries     Collect Motr binaries even if there are no core dumps.
    --nr-boots         How many boots to query systemd journal for\
 (default is $NR_BOOTS_MAX).
    -p, --path         Show locations of Motr binaries: m0d, m0tr.ko, etc.
    -V, --version      Show version number and exit.

If no explicit INPUT_DIR arguments are provided, the script will use
$DEFAULT_INPUT_DIRS_GLOB glob pattern.
EOF
}

optparse() {
    ##
    ## We do not want the program to proceed if invalid CLI options
    ## are provided.
    ##
    ## If TEMP variable was given a value at the place of its declaration
    ## (i.e. if we used `local TEMP=$(getopt ...)' expression), the program
    ## would ignore getopt errors!  On the contrary, when variable
    ## declaration and initialization are separated, any error of `getopt'
    ## command (e.g., invalid option) will result in program failure.
    ##
    local TEMP # do not assign value here
    TEMP=$(getopt -o hpbV --long help,addb,skip-addb-files,binaries,nr-boots:,path,version \
                  -n "${0##*/}" -- "$@")
    eval set -- "$TEMP"
    while true; do
        case "$1" in
            -h|--help) usage; exit 0;;
            --addb) COLLECT_ADDB_P=1;;
            --skip-addb-files) SKIP_ADDB_FILE_P=1;;
            -b|--binaries) COLLECT_BINARIES_P=1;;
            --nr-boots) NR_BOOTS_MAX=$2; shift;;
            -p|--path)
                for f in m0mkfs m0d m0tracedump m0addb2dump m0beck m0betool \
                         m0tr.ko libmotr{,-xcode-ff2c,-ut}.so libgalois.so; do
                    path $f
                done
                exit 0;;
            -V|--version) echo m0reportbug $VERSION; exit 0;;
            --) shift; break;;
            *) break;;
        esac
        shift
    done

    INPUT_DIRS=(${@:-$DEFAULT_INPUT_DIRS_GLOB})
}

[ $VERSION = "$(grep -A2 '^### Date' $PROG | tail -1 | cut -d' ' -f3)" ] ||
    warn 'VERSION must be updated'
main "$@"
exit

###
### History:
###
### Date       Version Description
### ---------- ------- ----------------------------------------------------
### 2020-10-19 0.53    Added addb-files options to collect addb files from
###                    both server(ioservice) and client(s3server)
###
### 2020-10-05 0.52    Removed halon related things since we are not using
###                    it.Removed collection of kernel buffer because we lack
###                    of debugfs support.Removed collection of m0traces of
###                    s3server and hax. Added 'df -h' to probe info. 
###
### 2020-10-02 0.51    Added /var/log/crash to CORE_DIRS list since on
###                    provisioner deployed setup, core would be in /var/log/crash
###
### 2020-09-21 0.50    updated m0reportbug to capture below recovery debug data
###                    1.m0betool and m0beck binaries.
###                    2.motr_data_recovery.sh and prov-m0-reset scripts
###                    3.motr_data_recovery log files.
###                    4.added probes for
###                     a. 'lsblk'
###                     b. 'lvdisplay'
###                     c. 'vgdisplay'
###                     d. 'pvdisplay'
###                    6.traces from RECOVERY_SCRIPT_DIR dir.
### 2020-06-09 0.49    Remove uncompressed live core from /var/crash, once it
###                    is compressed and bundled into m0reportbug-cores.tar.xz
###
### 2020-06-03 0.48    Updated m0reportbug to collect cores (compressed/
###                    uncompressed) from /var/crash. Live cores are also
###                    dumped into /var/crash and bundled later. Added prefix
###                    'live'(core-live.<pname>.<pid>) for live dumps.
###
### 2020-06-02 0.47    [bugfix] program_from_core(): make sure `basename`
###                    receives an operand.
###
### 2020-05-24 0.46    Handle empty core dumps.
###
### 2020-05-21 0.45    * Support multiple input directories, /var/motr* by
###                      default.
###                    * Don't strip directory name (e.g., '/var/motr')
###                      from the names of collected m0trace and addb files.
###                    * Do not collect m0trace files from /var/lib/halon
###                      directory.  To collect them, pass directory name
###                      explicitly as a command line argument.
###
### 2020-05-04 0.44    Limit the number of boots to collect journalctl output
###                    for.  Make this number configurable via `--nr-boots`
###                    CLI option.
###
### 2020-04-13 0.43    Ignore core dumps of s3server.  Those are collected by
###                    s3_bundle_generate.sh script.
###
### 2020-03-29 0.42    If `gcore` is not available, print a warning, don't fail.
###
### 2020-03-23 0.41    Generate core dumps of running Motr processes. They might
###                    be stuck in a dead-lock. In such cases backtraces might
###                    not provide all the required information.
###
### 2020-03-23 0.40    Add sysrq probe to collect system-wide information from
###                    /proc/sysrq-trigger commands (memory-usage, task-states,
###                    blocked-tasks, backtrace-all-active-cpus).
###
### 2019-12-11 0.39    When compressing files with `xz`, use as many threads
###                    as there are CPU cores on the system.
###
### 2019-11-06 0.38    Debug and silence halon-rg.json collection.
###
### 2019-10-15 0.37    Collect traces of `hax` executable.
###
### 2019-04-16 0.36    Get Halon RG (resource graph) data in JSON format.
###                    It can be converted into dynamic visualization
###                    with $H0_SRC_DIR/scripts/halon-rg-view script.
###
### 2018-12-07 0.35    path(): If m0reportbug path does not end with
###                    "/utils/m0reportbug", assume that executables and
###                    libraries were installed from rpms (we wouldn't
###                    know where to look for them if they weren't).
###
### 2018-11-27 0.34    * [bugfix] misc_files(): Don't stop if /etc/motr/
###                      doesn't exist --- proceed with collecting other
###                      files.  This fixes the problem of conf.xc and
###                      halon files (facts, decision log) not being
###                      collected.
###                    * Do not require superuser permissions to show help
###                      message.
###                    * misc_files(): Make it possible for
###                      halon.decision.log to be found even if /var/log
###                      is a symbolic link.
###
### 2018-11-10 0.33    * Replace `hctl motr status` with more informative
###                      `hctl motr status -d`.
###                    * Explain why `m0version` is needed.
###
### 2018-11-08 0.32    * Find m0tr.ko in /lib/modules, not /lib/module.
###
### 2018-10-03 0.31    * m0mkfs executable has moved into /usr/sbin (was in
###                      /usr/bin before).
###
### 2018-06-14 0.30    * [bugfix] _kdump_files(): Add missing quotes to
###                      prevent "[: argument expected" error.
###                    * m0traces(): Get halond m0traces from /var/lib/halon/
###                      directory (again).
###                    * backtraces_cores(): Collect core dumps from
###                      /var/lib/halon/ directory.
###                    * binaries(): Collect /usr/bin/halond.
###
### 2018-04-08 0.29    Clean old m0reportbug output before generating new.
###
### 2018-03-28 0.28    Don't check the version of Motr package. This check
###                    has outlived its usefulness.
###
### 2018-03-02 0.27    Bump MOTR_PACKAGE_VERSION to 1.2.0.
###
### 2017-08-23 0.26    Switch to xz compression.
###
### 2017-08-23 0.25    * Collect logrotated Halon decision logs
###                      (/var/log/halon.decision.log-*.gz).
###                    * Put journalctl output into a separate file.
###
### 2017-08-15 0.24    * Use contemporary ("master") hctl commands.
###                    * Add `hctl halon info rc' probe.
###
### 2017-08-13 0.23    * Bump MOTR_PACKAGE_VERSION to 1.1.0.
###                    * gdb_bt(): Don't use `-batch' option of gdb ---
###                      it suppresses gdb commands output.
###                      (Used to work fine with older gdb though.)
###                    * _path_rpm(), _path_src(): Don't expect libmotr.so.*
###                      file to end with MOTR_PACKAGE_VERSION --- libtool
###                      uses its own version numbering algorithm.
###                    * program_from_core(): Don't treat single quote symbol
###                      as part of the file name.
###                    * Add `hctl motr status' probe.
###
### 2017-06-23 0.22.2  Disable `df -h' entirely.
###
### 2017-05-26 0.22.1  Set LC_ALL=C.
###
### 2017-03-30 0.22    * program_from_core(): If there is no executable name
###                      in `file' output, fall back to `gdb -batch'.
###                    * misc_files(): Do not complain if /etc/motr directory
###                      is missing.
###                    * Add `python' to _path_src() and _path_rpm().
###                    * Fix some of SC2016 warnings reported by shellcheck.
###
### 2017-02-21 0.21    * misc_files(): Collect /var/crash/*/vmcore-dmesg.txt.
###                    * Add `lctl dk' probe.
###
### 2017-02-09 0.20    backtraces_live(): Collect backtrace of halond.
###
### 2016-12-21 0.19    Produce 3 output archives:
###                    - m0reportbug-cores.tar.gz (cores & binaries);
###                    - m0reportbug-traces.tar.gz (m0traces);
###                    - m0reportbug-data.tar.gz (main report & other data).
###
### 2016-12-21 0.18    * Add `m0ham' to _path_src(), _path_rpm() and binaries().
###                    * Use proper path to libmotr.so.
###
### 2016-12-05 0.17    Bump MOTR_PACKAGE_VERSION to 1.0.0.
###                    check_package_version(): New function.
###
### 2016-11-17 0.16    * m0traces(): Change location of halond traces to
###                      /var/log/.
###                    * If m0trace or m0tracedump is not found, don't try
###                      to run it.
###                    * Collect /etc/halon/halon_facts.yaml, if available.
###                    * New probes: hctl cluster status, hctl debug eq,
###                      hctl debug cep.
###                    * Don't leave empty cores/ directory.
###                    * Collect binaries only if there are core dumps fetched
###                      or `--binaries' option is provided.
###
### 2016-10-05 0.15.1  Show dependencies of Motr and Halon rpms.
###
### 2016-09-06 0.15    More probes: halond -v, rpm -qi halon, systemctl status,
###                    etc.
###
### 2016-08-15 0.14.3  Get /var/log/halon.decision.log.
###
### 2016-05-29 0.14.2  Don't query free space of `m0t1fs' and `nfs' mount
###                    point(s).
###
### 2016-04-21 0.14.1  * Add `m0ut' to _path_rpm().
###                    * Add `lt-m0mkfs' to _path_src().
###                    * Suppress "No such file" warning for the binaries,
###                      which are provided by optional rpms.
###                    * Use "**ERROR**" prefix to make errors noticeable.
###
### 2016-04-05 0.14    Collect Halon data: /tmp/halond.log file,
###                    /var/log/halon-persistence/ directory, m0traces
###                    from /var/lib/halon/ directory.
###
### 2016-03-29 0.13.2  misc_files(): Don't fail if some file is missing.
###                    `/var/motr/confd/conf.xc', referred to by
###                    MOTR_CONF_XC variable, is not guaranteed to exist.
###
### 2016-03-03 0.13.1  Add `lt-m0rwlock' to _path_src().
###
### 2016-03-01 0.13    * m0traces(): Collect at least two trace files from
###                      each of $IN_DIR/m0d-*/ directories.
###                    * Collect /etc/sysconfig/{m0d,m0t1fs,motr}* files.
###                    * Collect $IN_DIR/*.{log,xc} files.
###
### 2016-02-24 0.12    Collect kernel buffer if possible.
###
### 2016-02-04 0.11.1  Warn, don't fail in case of VERSION discrepancy.
###
### 2016-02-04 0.11    * Collect /etc/motr/genders.
###                    * Get stack of `mount' process.
###
### 2016-02-02 0.10.2  Add `df -h' probe.
###
### 2016-01-27 0.10.1  * _path_src() is able to handle `lt-m0d'.
###                    * Compare VERSION with that of the topmost History
###                      entry. Fail if the values differ.
###
### 2016-01-19 0.10    Create .tar.gz archive. bzip2 is not always available.
###
### 2016-01-05 0.9.2   * Do not collect ADDB data unless `--addb' option
###                      is provided. (Collection of ADDB data may hang.)
###                    * Don't tolerate invalid CLI options.
###                    * Perform optional ADDB collection at the very end
###                      of the execution.
###
### 2015-12-31 0.9.1   [fix] gdb_bt(): Do not call `dirname' without argument.
###
### 2015-12-29 0.9     * Collect addb data.
###                    * Add `journalctl' probe.
###                    * Do not fetch binaries unless there is a core dump
###                      or `-b' CLI option is provided.
###                    * Show duration of slow stages.
###                    * [bugfix] _path_rpm(): Use proper quotes.
###
### 2015-12-24 0.8.1   Do not attach gdb to dd and fio processes.
###
### 2015-12-10 0.8     * Require superuser privileges; drop sudo-s.
###                    * Fetch binaries: libmotr.so, m0mkfs, m0d, lt-m0ut, etc.
###                    * Pack results into .tar.bz2 archive.
###                    * gdb_bt(): Show `info sharedlibrary'.
###
### 2015-12-08 0.7.1   * Core dumps and m0trace files may be not world-readable.
###                      Run `touch -r' with sudo.
###                    * Canonicalize $IN_DIR to allow symbolic links.
###
### 2015-12-04 0.7     * Use preset paths, different for rpm and non-rpm
###                      (source) installations.
###                    * Tolerate the absence of gdb.
###                    * Collect no more than 20 most recent m0trace files.
###                    * Limit the size of _compressed_ core dump file,
###                      not the original file.
###                    * gdb_bt(): set solib-search-path to obtain meaningful
###                      backtraces at Jenkins nodes.
###                    * backtraces_live(): Don't fail if a process disappears.
###                    * Add `--path' CLI option.
###
### 2015-11-25 0.6     * Add more probes.
###                    * Collect stderr output of probes.
###                    * Get stacks of `dd' and `fio' processes.
###                    * Update backtraces_cores() to work on Jenkins nodes.
###                    * Add `--version' CLI option.
###                    * [bugfix] backtraces_live(): Make `lt-' prefix optional.
###
### 2015-11-15 0.5.1   Specify input directory via CLI argument.
###
### 2015-11-03 0.4     * Delete old $OUT_DATA_DIR without asking user.
###                    * Let the packed m0trace files have timestamps
###                      of original files.
###                    * [bugfix] Fix the issue of `find_exec' not working
###                      properly with relative paths.
###
### 2015-10-31 0.3     Process raw m0traces with `m0tracedump'.
###
### 2015-10-27 0.2     `m0version' calls `m0d -v'.
###
### 2015-10-19 0.1     Initial release: system probes, backtraces (running
###                    lt-m0* processes, core dumps), m0traces.
###
