#!/usr/bin/env python3
#
# Copyright (c) 2020 Seagate Technology LLC and/or its Affiliates
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# For any questions about this software or licensing,
# please email opensource@seagate.com or cortx-questions@seagate.com.
#


from ply import lex, yacc
import argparse
import contextlib
import json
import os
import re
import sys
import textwrap
from collections import OrderedDict
from curses import ascii
from errno import EPIPE
from functools import reduce  # there is no `reduce' in python3
import unittest

# ----------------------------------------------------------------------
# XXX Any change of Motr conf schema (e.g., addition of new field to a
# conf object type) requires modification of .cg files and xcode
# strings.  Manual editing of all those files is error-prone and
# boring as hell.
#
# TODO:
#
# - Add "QuickCheck" mode: m0confgen generates random conf data that
#   satisfies certain properties (e.g., number and types of services,
#   number of drives and pools) specified in optional input file,
#   prepared by user.  This might be implemented using Hypothesis
#   library [https://github.com/HypothesisWorks/hypothesis-python/].
# ----------------------------------------------------------------------

__version__ = '2.0'
__author__ = 'opensource@seagate.com'
__copyright__ = """

  Copyright (c) 2018-2020 Seagate Technology LLC and/or its Affiliates

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  For any questions about this software or licensing,
  please email opensource@seagate.com or cortx-questions@seagate.com.

"""
__doc__ = """Configuration string converter.

Converts configuration string from one format into another.

Input formats: {input_formats}.
Output formats: {output_formats}.
"""
__all__ = ['Fid', 'ConfObj', 'conf_objs_from_str', 'conf_objs_to_str',
           'conf_obj_types', 'Error']

# NOTE: These definitions should be in sync with m0_confx_* structures
# in conf/onwire.h.
#
# Relation attributes (references to other objects) are marked either
# with '*' (solid line on visualisation) or '!' (dashed line).
#
# XXX TODO: s/objid/fid/g ?
conf_obj_types = {
    'root': ('t', 'verno=NUMBER rootfid=fid mdpool=objid imeta_pver=fid'
             ' mdredundancy=NUMBER params=[STRING] *nodes=[objid]'
             ' *sites=[objid] *pools=[objid] *profiles=[objid]'
             ' *fdmi_flt_grps=[objid]'),
    'fdmi_flt_grp': ('g', 'rec_type=NUMBER *filters=[objid]'),
    'fdmi_filter': ('l', 'id=fid root=STRING node=objid endpoints=[STRING]'),

    # Software:
    'node': ('n', 'memsize=NUMBER nr_cpu=NUMBER last_state=NUMBER flags=NUMBER'
             ' *processes=[objid]'),
    'process': ('r', 'cores=[NUMBER] mem_limit_as=NUMBER mem_limit_rss=NUMBER'
                ' mem_limit_stack=NUMBER mem_limit_memlock=NUMBER'
                ' endpoint=STRING *services=[objid]'),
    'service': ('s', 'type=NUMBER endpoints=[STRING] params=[STRING]'
                ' *sdevs=[objid]'),
    'sdev': ('d', 'dev_idx=NUMBER iface=NUMBER media=NUMBER bsize=NUMBER'
             ' size=NUMBER last_state=NUMBER flags=NUMBER filename=STRING'),

    # Hardware:
    'site': ('S', '*racks=[objid] pvers=[objid]'),
    'rack': ('a', '*encls=[objid] pvers=[objid]'),
    'enclosure': ('e', '!node=objid *ctrls=[objid] pvers=[objid]'),
    'controller': ('c', '*drives=[objid] pvers=[objid]'),
    'drive': ('k', '!dev=objid pvers=[objid]'),

    # Pools:
    'pool': ('o', 'pver_policy=NUMBER *pvers=[objid]'),
    'pver': ('v:0',  # actual pver
             'N=NUMBER K=NUMBER P=NUMBER tolerance=[NUMBER] *sitevs=[objid]'),
    'pver_f': ('v:1',  # formulaic pver
               'id=NUMBER !base=objid allowance=[NUMBER]'),
    'objv': ('j', '!real=objid *children=[objid]'),
    'profile': ('p', '!pools=[objid]')
}

# NOTE: Should be in sync with m0_conf_service_type in conf/schema.h.
conf_service_types = (
    '_UNUSED', 'MDS', 'IOS', 'CONFD', 'RMS', 'STATS', 'HA', 'SSS',
    'SNS_REP', 'SNS_REB', 'ADDB2', 'CAS', 'DIX_REP', 'DIX_REB',
    'DS1', 'DS2',  # UT-specific
    'FIS', 'FDMI', 'BE', 'M0T1FS', 'CLIENT', 'ISCS', 'DTM0'
)
conf_service_types = tuple('M0_CST_' + s for s in conf_service_types)


# --------------------------------------------------------------------
# Helpers

class Error(Exception):
    pass


def all_unique(xs):
    """Returns True iff all entries of the sequence are unique."""
    return len(xs) == len(set(xs))


def bits(num, start_bit, nr_bits):
    """Returns `nr_bits' of `num', starting at `start_bit'."""
    return num >> start_bit & 2**nr_bits - 1


def delete_chars(s, deletechars):
    assert type(deletechars) is str
    if sys.version_info.major < 3:
        return s.translate(None, deletechars)  # Python 2 version
    return s.translate({ord(c): None for c in deletechars})


def quote(s):
    return '"{}"'.format(s)


# --------------------------------------------------------------------
# Internal representation

class Fid(object):

    def __init__(self, container, key):
        try:
            # see M0_FID_TCONTAINER() in fid/fid.h
            if type(container) is tuple:
                car, cdr = container
                if type(car) is str:
                    car = ord(car)
                assert car >= 0 and car.bit_length() <= 8
                assert cdr >= 0 and cdr.bit_length() <= 56
                self.tcontainer = car, cdr
            else:
                assert container >= 0 and container.bit_length() <= 64
                self.tcontainer = (container >> 56,
                                   container & 0x00ffffffffffffff)
            assert key >= 0 and key.bit_length() <= 64
            self.key = key
        except AssertionError:
            raise ValueError

    def __repr__(self):
        if self.typebyte() == 0:
            return '{}({}, {})'.format(self.__class__.__name__,
                                       self.tcontainer[1], self.key)
        ft_id = self.typebyte()
        if ascii.isprint(ft_id):
            ft_id = repr(chr(ft_id))
        return '{}(({}, {}), {})'.format(self.__class__.__name__,
                                         ft_id, self.tcontainer[1], self.key)

    def __eq__(self, other):
        return self.tcontainer == other.tcontainer and self.key == other.key

    def typebyte(self):  # aka "ft_id"
        return self.tcontainer[0]

    def container(self):
        return self.tcontainer[0] << 56 | self.tcontainer[1]


class ConfObjType(object):

    def __init__(self, name, ft_id, desc):
        assert all([type(x) is str for x in (name, ft_id, desc)])
        self.name = name
        self.ft_id = ft_id[0]
        self.union_tag = None
        if ft_id[1:]:
            assert ft_id[1] == ':'
            self.union_tag = int(ft_id[2:])
        self.attrs = [ConfObjAttrType(*a.split('=', 1)) for a in desc.split()]
        self.desc = desc

    def __repr__(self):
        ft_id = self.ft_id
        if self.union_tag is not None:
            ft_id += ':' + str(self.union_tag)
        return '{}({!r}, {!r}, {!r})'.format(self.__class__.__name__,
                                             self.name, ft_id, self.desc)

    def to_fid(self, container, key):
        if self.union_tag is None:
            return Fid((self.ft_id, container), key)
        assert self.union_tag.bit_length() <= 2
        if container & 0x00c0000000000000:
            raise Error('Union tag bits are not zero: {:#x}'.format(container))
        assert container.bit_length() <= 56
        return Fid(ord(self.ft_id) << 56 | self.union_tag << 54 | container,
                   key)

    @staticmethod
    def from_fid(fid):
        assert type(fid) is Fid
        ts = [t for t in conf_obj_types.values()
              if t.ft_id == chr(fid.typebyte())]
        if not ts:
            return None  # not a conf fid
        if ts[1:]:
            assert all([t.union_tag is not None for t in ts])
            ts = [t for t in ts
                  if bits(fid.tcontainer[1], 54, 2) == t.union_tag]
            if len(ts) != 1:
                raise Error('Unsupported union tag: {:#x}'.format(
                    fid.container()))
        t = ts[0]
        if t.union_tag is None:
            assert t.to_fid(fid.tcontainer[1], fid.key) == fid
        else:
            # clear union tag bits
            assert t.to_fid(fid.tcontainer[1] & ~0x00c0000000000000,
                            fid.key) == fid
        return t


class ConfObjAttrType(object):

    def __init__(self, name, type_desc):
        if name[0] in '*!':
            self.relation, self.name = name[0], name[1:]
        else:
            self.relation, self.name = '', name
        self.type_desc = type_desc

    def __repr__(self):
        return '{}({!r}, {!r})'.format(self.__class__.__name__,
                                       self.relation + self.name,
                                       self.type_desc)


conf_obj_types = dict((name, ConfObjType(name, *desc))
                      for name, desc in conf_obj_types.items())
assert all([k == t.name for k, t in conf_obj_types.items()])
assert all_unique([(t.ft_id, t.union_tag) for t in conf_obj_types.values()])


class ConfObj(object):

    def __init__(self, objid, attrs):
        otype = ConfObjType.from_fid(objid)
        attrs = list(attrs)
        assert attrs
        assert all([type(x) is tuple and len(x) == 2 for x in attrs])
        anames = set([k for k, _ in attrs])
        assert len(attrs) == len(list(anames)), 'Attribute reassignment'
        otype_anames = set([a.name for a in otype.attrs])
        if anames != otype_anames:
            missing = [a for a in otype_anames - anames]
            unknown = [a for a in anames - otype_anames]
            err = '{}: Invalid attributes'.format(objid)
            if missing:
                err += '\n  missing: ' + ', '.join(sorted(missing))
            if unknown:
                err += '\n  unknown: ' + ', '.join(unknown)
            raise Error(err)
        self.objid = objid
        attrs = dict(attrs)
        self.attrs = [attrs[a.name] for a in otype.attrs]

    def __repr__(self):
        otype = ConfObjType.from_fid(self.objid)
        return '{}({!r}, {!r})'.format(
            self.__class__.__name__, self.objid,
            list(zip([a.name for a in otype.attrs], self.attrs)))

    def __eq__(self, other):
        return self.objid == other.objid and self.attrs == other.attrs


# --------------------------------------------------------------------
# Encoding (internal representation -> string)

output_formats = ['confgen', 'xcode', 'json', 'html', 'dot']


class BaseEncoder(object):

    @classmethod
    def typed(cls, desc):
        """Selects encoder given the description of the kind of input data.
        """
        assert type(desc) is str
        list_p = False
        if desc[0] == '[':
            assert desc[-1] == ']'
            list_p = True
            desc = desc[1:-1]
        enc = {
            'NUMBER': cls.encode_NUMBER,
            'STRING': cls.encode_STRING,
            'fid': cls.encode_Fid,
            'objid': cls.encode_objid,
        }[desc]
        if list_p:
            return lambda xs: cls.encode_list(list(map(enc, xs)))
        return enc

    @classmethod
    def encode(cls, objs):
        assert type(objs) is list
        assert all([type(x) is ConfObj for x in objs])
        return cls.head(objs) + cls.body(objs) + cls.tail if objs else ''

    @classmethod
    def body(cls, objs):
        return cls.separator.join([cls.indentation + cls.encode_ConfObj(obj)
                                   for obj in objs])

    @staticmethod
    def dec_or_hex(n):
        return str(n) if n < 100 else hex(n)

    @classmethod
    def encode_NUMBER(cls, n):
        if type(n) is int:
            return cls.dec_or_hex(n)
        assert type(n) is str and n[0] == '@'
        return n

    @staticmethod
    def encode_STRING(s):
        assert type(s) is str
        return quote(s)

    @classmethod
    def encode_Fid(cls, fid):
        if ConfObjType.from_fid(fid) is None:
            return '({}, {})'.format(*map(cls.dec_or_hex,
                                          [fid.container(), fid.key]))
        return cls.encode_Fid__conf(fid)

    @classmethod
    def encode_objid(cls, fid):
        if ConfObjType.from_fid(fid) is None:
            raise Error('Conf fid expected: {}'.format(fid))
        return cls.encode_Fid__conf(fid)


class Encoder_xc(BaseEncoder):

    @staticmethod
    def head(objs):
        return '[{}:\n'.format(len(objs))

    indentation = ' '
    separator = ',\n'
    tail = ']'

    @staticmethod
    def encode_list(xs):
        assert type(xs) is list
        return '[{}: {}]'.format(len(xs), ', '.join(xs)) if xs else '[0]'

    @classmethod
    def encode_Fid__conf(cls, fid):
        otype = ConfObjType.from_fid(fid)
        assert otype is not None
        assert ord(otype.ft_id) == fid.typebyte()
        return '^{}|{}:{}'.format(
            otype.ft_id, *map(cls.dec_or_hex, [fid.tcontainer[1], fid.key]))

    @classmethod
    def encode_ConfObj(cls, obj):
        assert type(obj) is ConfObj
        otype = ConfObjType.from_fid(obj.objid)
        assert len(otype.attrs) == len(obj.attrs)
        return '{{{ft_id:#x}| (({objid}), {union_begin}{attrs}{union_end})}}'.\
            format(
                ft_id=ord(otype.ft_id), objid=cls.encode_objid(obj.objid),
                union_begin=('' if otype.union_tag is None else
                             '{{{}| ('.format(otype.union_tag)),
                attrs=', '.join([cls.typed(ta.type_desc)(a)
                                 for ta, a in zip(otype.attrs, obj.attrs)]),
                union_end=('' if otype.union_tag is None else ')}'))


class Encoder_cg(BaseEncoder):

    @staticmethod
    def head(objs):
        return ''

    indentation = ''
    separator = '\n'
    tail = ''

    @staticmethod
    def encode_list(xs):
        assert type(xs) is list
        return '[{}]'.format(', '.join(xs))

    @classmethod
    def encode_Fid__conf(cls, fid):
        otype = ConfObjType.from_fid(fid)
        assert otype is not None
        container = fid.tcontainer[1]
        if otype.union_tag is not None:
            assert bits(container, 54, 2) == otype.union_tag
            container &= 0x003fffffffffffff  # clear union_tag bits
        return '{type}-{container}{key}'.format(
            type=otype.name,
            container=('' if container == 1 else
                       cls.dec_or_hex(container) + ':'),
            key=cls.dec_or_hex(fid.key))

    @classmethod
    def encode_ConfObj(cls, obj):
        assert type(obj) is ConfObj
        otype = ConfObjType.from_fid(obj.objid)
        assert len(otype.attrs) == len(obj.attrs)
        return '({objid} {attrs})'.format(
            objid=cls.encode_objid(obj.objid),
            attrs=' '.join([ta.name + '=' + cls.typed(ta.type_desc)(a)
                            for ta, a in zip(otype.attrs, obj.attrs)]))


class Encoder_json(Encoder_cg):

    @staticmethod
    def head(objs):
        return '[\n'

    indentation = ' '
    separator = ',\n'
    tail = '\n]'

    @staticmethod
    def encode_list(xs):
        assert type(xs) is list
        return xs

    @staticmethod
    def encode_NUMBER(n):
        if type(n) is str:
            assert n[0] == '@'
        else:
            assert type(n) is int
        return n

    @staticmethod
    def encode_STRING(s):
        assert type(s) is str
        return s

    @classmethod
    def encode_Fid(cls, fid):
        if ConfObjType.from_fid(fid) is None:
            return fid.container(), fid.key
        return cls.encode_Fid__conf(fid)

    @classmethod
    def encode_ConfObj(cls, obj):
        assert type(obj) is ConfObj
        otype = ConfObjType.from_fid(obj.objid)
        assert len(otype.attrs) == len(obj.attrs)
        return json.dumps(OrderedDict(
            [('objid', cls.encode_objid(obj.objid))] +
            [(ta.name, cls.typed(ta.type_desc)(a))
             for ta, a in zip(otype.attrs, obj.attrs)]))


class Encoder_html(Encoder_cg):

    @staticmethod
    def head(objs):
        return """\
<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>conf</title>
    <style>
        body {
            color: #d3d3d3;
            font: 12pt arial;
            background-color: #222222;
        }
        #network {
            width: 1000px;
            height: 500px;
            border: 1px solid #444444;
            background-color: #222222;
        }
        table {
            border-collapse: collapse;
        }
        table td {
            border: 1px solid;
        }
    </style>
    <script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.19.1/vis.min.js">
    </script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.19.1/vis.min.css"
        rel="stylesheet" type="text/css">
</head>
<body>
<div id="network">
<script type="text/javascript">
"""

    @classmethod
    def array_entries(cls, obj):
        """ConfObj -> (string, [string])

        Returns a tuple of
        - `nodes' array entry;
        - list of `edges' array entries.
        """
        otype = ConfObjType.from_fid(obj.objid)
        assert otype is not None
        fid = cls.encode_objid(obj.objid)

        def edge_to(target, relation):
            edge = OrderedDict([('from', fid),
                                ('to', cls.encode_objid(target))])
            if relation == '!':
                edge['dashes'] = True
            else:
                assert relation == '*'
            return edge

        node = OrderedDict([('id', fid), ('label', fid), ('group', otype.name),
                            ('_attrs', OrderedDict())])
        edges = []
        for ta, a in zip(otype.attrs, obj.attrs):
            node['_attrs'][ta.name] = cls.typed(ta.type_desc)(a)
            if ta.relation:
                if type(a) is list:
                    edges += [edge_to(x, ta.relation) for x in a]
                else:
                    edges.append(edge_to(a, ta.relation))
        return json.dumps(node), list(map(json.dumps, edges))

    indentation = ' '*4
    separator = ',\n'

    @classmethod
    def body(cls, objs):
        nodes, edges = zip(*map(cls.array_entries, objs))
        edges = reduce(list.__add__, edges)
        return """\
{indent}var nodes = [
{nodes}
{indent}];
{indent}var edges = [
{edges}
{indent}];
""".format(indent=cls.indentation,
           nodes=cls.separator.join([cls.indentation*2 + s for s in nodes]),
           edges=cls.separator.join([cls.indentation*2 + s for s in edges]))

    tail = """
    var container = document.getElementById("network");
    var data = {
        nodes: nodes,
        edges: edges
    };
    var options = {
        edges: {
            arrows: {
                to: {enabled: true}
            }
        }
    };
    network = new vis.Network(container, data, options);

    network.on("selectNode", function (params) {
        var obj_id = params.nodes[0];
        var obj_attrs = nodes.find(function (x) {
            return x.id == obj_id;
        })._attrs;

        table_delete();
        var table = document.createElement("table");
        var caption = document.createElement("caption");
        caption.appendChild(document.createTextNode(obj_id));
        table.appendChild(caption);
        for (var k in obj_attrs) {
            var tr = table.insertRow();
            var td = tr.insertCell();
            td.appendChild(document.createTextNode(k));
            var td = tr.insertCell();
            td.appendChild(document.createTextNode(obj_attrs[k]));
        }
        document.body.appendChild(table);
    });

    network.on("deselectNode", function (params) {
        table_delete();
    });

    function table_delete() {
        var elem = document.getElementsByTagName("table")[0];
        if (elem) {
            elem.parentNode.removeChild(elem);
        }
    }
</script>
</body>
</html>"""


class Encoder_dot(Encoder_cg):

    @staticmethod
    def head(objs):
        return 'digraph conf {\n'

    indentation = ''
    separator = '\n'
    tail = '\n}'

    @classmethod
    def encode_ConfObj(cls, obj):
        assert type(obj) is ConfObj
        otype = ConfObjType.from_fid(obj.objid)
        assert len(otype.attrs) == len(obj.attrs)
        objid = cls.encode_Fid__conf(obj.objid)
        lines = [quote(objid) + ';']
        for ta, a in zip(otype.attrs, obj.attrs):
            if ta.relation != '*':
                continue
            if type(a) is not list:
                lines.append('{} -> {} [label={}];'.format(
                    quote(objid), quote(cls.encode_Fid__conf(a)),
                    quote(ta.name)))
                continue
            if not a:
                continue  # don't show empty directories
            dirid = 'dir_{}_{}'.format(objid, ta.name)
            lines.append('{} [height=0.15, width=0.15, label=""];'.format(
                quote(dirid)))
            lines.append('{} -> {} [label={}];'.format(
                quote(objid), quote(dirid), quote(ta.name)))
            for child in a:
                lines.append('{} -> {};'.format(
                    quote(dirid), quote(cls.encode_Fid__conf(child))))
        return cls.separator.join(' '*4 + r for r in lines)


def fid_translate(fid):
    assert type(fid) is Fid
    if ConfObjType.from_fid(fid) is not None:
        return Encoder_cg.encode_Fid(fid)
    if chr(fid.typebyte()) == 'D':
        # Byte 7 of fid.container() = type of dir's parent.
        # Byte 6 of fid.container() = type of dir's children.
        # See conf_dir_id_build() in conf/dir.c.
        parent = Fid((fid.tcontainer[1] >> 48 & 0xff,
                      fid.tcontainer[1] & 0xffffffffff),
                     fid.key)
        child = Fid((fid.tcontainer[1] >> 40 & 0xff, 1), 0)  # a counterfeit
        if all([ConfObjType.from_fid(x) is not None for x in (parent, child)]):
            return 'dir_{}_{}'.format(Encoder_cg.encode_Fid(parent),
                                      ConfObjType.from_fid(child).name)
    if chr(fid.typebyte()) == '/' and fid.tcontainer[1] == 0:
        # see M0_CONF_REL_FIDS in conf/obj.h
        rel_fids = {0xffffffffffffffff: 'M0_CONF_ANY_FID'}
        rel_fids.update((i+1, 'M0_CONF_' + s + '_FID') for i, s in
                        enumerate(['ROOT_NODES',
                                   'ROOT_SITES',
                                   'ROOT_POOLS',
                                   'ROOT_PROFILES',
                                   'ROOT_FDMI_FLT_GRPS',
                                   'FDMI_FGRP_FILTERS',
                                   'POOL_PVERS',
                                   'PVER_SITEVS',
                                   'SITEV_RACKVS',
                                   'RACKV_ENCLVS',
                                   'ENCLV_CTRLVS',
                                   'CTRLV_DRIVEVS',
                                   'NODE_PROCESSES',
                                   'PROCESS_SERVICES',
                                   'SERVICE_SDEVS',
                                   'SITE_RACKS',
                                   'RACK_ENCLS',
                                   'ENCLOSURE_CTRLS',
                                   'CONTROLLER_DRIVES']))
        return rel_fids.get(fid.key)


if sys.version_info.major < 3:
    # raw_input() has been renamed to input() in Python 3.0
    # https://docs.python.org/3/whatsnew/3.0.html#index-32
    input = raw_input


def fids_translate():
    while True:
        try:
            s = input('> ' if sys.stdin.isatty() else '').rstrip('\r')
            for s in s.split():  # allow several fids per line
                print(' '.join(filter(None, [s, fid_translate(fid_scan(s))])))
        except Error as e:
            print(e, file=sys.stderr)
            continue
        except (EOFError, KeyboardInterrupt):
            return


def conf_objs_to_str(objs, to_fmt):
    """conf_objs_to_str(conf_objs, format) -> string

    Converts a list of conf objects (ConfObj) into a string of
    specific format.
    """
    encoders = OrderedDict([('confgen', Encoder_cg.encode),
                            ('xcode', Encoder_xc.encode),
                            ('json', Encoder_json.encode),
                            ('html', Encoder_html.encode),
                            ('dot', Encoder_dot.encode)])
    assert list(encoders.keys()) == output_formats
    return encoders[to_fmt](objs)


# --------------------------------------------------------------------
# Decoding (string -> internal representation)

input_formats = ['confgen', 'xcode']

confgen_doc = """"confgen" format:

    input   = [ seq(obj) ]
    seq(t)  = *( t )
    csv(t)  = t | csv(t) "," t
    obj     = "(" objid *( attr ) ")"
    objid   = objtype "-" [ NUMBER ":" ] NUMBER
    attr    = ID "=" ( NUMBER | STRING | enum | fid | objid | list )
    fid     = "(" NUMBER "," NUMBER ")"
    enum    = "@" ID
    list    = "[" [ csv(NUMBER) | csv(STRING) | csv(objid) ] "]"
    objtype = { %(objtypes)s }

Notes on objid specification:

    Generic descriptor
        <objtype>-<container>:<key>
    may be shortened to
        <objtype>-<key>
    when the <container> part is 1.

Examples:

    (root-0 verno=1 rootfid=(11, 12) mdpool=pool-5 imeta_pver=(0, 0)
        mdredundancy=4 params=["param-0", "param-1", "param-2"]
        nodes=[node-1, node-2] sites=[site-3] pools=[pool-4, pool-5]
        profiles=[profile-2:3, profile-2:7] fdmi_flt_grps=[])
    (profile-2:3 pools=[pool-4, pool-5])
    (profile-2:7 pools=[pool-5])

Configuration object types and attributes:

    %(attrs)s""" % {
        'objtypes': textwrap.fill(
            ' | '.join(map(quote, sorted(conf_obj_types.keys()))),
            width=63, subsequent_indent=' '*16),
        'attrs': '\n    '.join('{:14}{}'.format(
            k + ':',
            textwrap.fill(delete_chars(t.desc, '*!'),
                          width=60,
                          subsequent_indent=' '*22))
                               for k, t in sorted(conf_obj_types.items()))
    }


class Lexer(object):

    tokens = ('HEXNUM', 'OCTNUM', 'DECNUM', 'STRING', 'ID', 'ENUM')
    literals = '()[]-=,:'
    t_ignore = ' \t\r\v'
    t_ID = r'\b[a-zA-Z]\w*\b'
    t_ENUM = r'@[a-zA-Z]\w*'

    def __init__(self, **kwargs):
        self.lexer = lex.lex(module=self, **kwargs)
        self.input = self.lexer.input
        self.token = self.lexer.token
        self.lineno = self.lexer.lineno
        self.lexpos = self.lexer.lexpos

    def t_HEXNUM(self, t):
        r'\b0[xX][0-9a-fA-F]+\b'
        t.value = int(t.value, 16)
        return t

    def t_OCTNUM(self, t):
        r'\b0[0-7]+\b'
        t.value = int(t.value, 8)
        return t

    def t_DECNUM(self, t):
        r'\b\d+\b'
        t.value = int(t.value)
        return t

    def t_STRING(self, t):
        r'"[^"]*"'
        t.value = t.value[1:-1]
        return t

    def t_comment(self, t):
        r'\#.*'

    def t_newline(self, t):
        r'\n+'
        t.lexer.lineno += len(t.value)

    def t_error(self, t):
        raise Error("Illegal character '%s' at byte %u" % (t.value[0],
                                                           t.lexpos + 1))

    def test(self, data):
        self.input(data)
        while True:
            t = self.token()
            if t is None:
                break
            print(t, file=sys.stderr)


class Lexer_xc(Lexer):

    literals = Lexer.literals + '{}|^'


# According to PLY documentation [6.12 Miscellaneous Yacc Notes;
# http://www.dabeaz.com/ply/ply.html#ply_nn36]:
#
# | [...] be aware that only one parser may be defined in a single module
# | (source file). There are various error checks and validation steps
# | that may issue confusing error messages if you try to define multiple
# | parsers in the same source file.
#
# That is why there is no global `parser' variable defined.

class BaseParser(object):

    debug = False  # create `parser.out'?
    write_tables = False  # create `parsetab.py'?
    tracking = True  # track positions of all grammar symbols, not only tokens?

    def __init__(self, **kwargs):
        assert hasattr(self, 'lexer')
        assert hasattr(self, 'start')
        self.tokens = Lexer.tokens
        kwargs.setdefault('debug', self.debug)
        kwargs.setdefault('write_tables', self.write_tables)
        self.parser = yacc.yacc(module=self, **kwargs)

    def parse(self, *args, **kwargs):
        kwargs.setdefault('lexer', self.lexer)
        kwargs.setdefault('tracking', self.tracking)
        return self.parser.parse(*args, **kwargs)

    def p_empty(self, p):
        """empty :"""

    def p_number(self, p):
        """number : DECNUM
                  | HEXNUM
                  | OCTNUM
        """
        p[0] = p[1]

    def p_fid(self, p):
        """fid : '(' number ',' number ')'"""
        p[0] = Fid(p[2], p[4])

    def p__ns(self, p):
        """numbers : number
                   | numbers ',' number
           strings : STRING
                   | strings ',' STRING
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[3]]

    def position(self, p, n):
        return ' at byte %u' % (p.lexpos(n) + 1) if self.tracking else ''

    # Note that the argument is a token, not a parser.
    def p_error(self, t):
        if t is None:
            raise Error('Unexpected EOF')
        raise Error('Syntax error at byte %u' % (t.lexpos + 1))


class Parser_cg(BaseParser):
    """Parses string in "m0confgen" format."""

    def __init__(self, **kwargs):
        self.lexer = Lexer()
        self.start = 'maybe_objs'
        super(self.__class__, self).__init__(**kwargs)

    def p_maybe_objs(self, p):
        """maybe_objs : objs
                      | empty
        """
        p[0] = [] if p[1] is None else p[1]

    def p_objs(self, p):
        """objs : obj
                | objs obj
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[2]]

    def p_obj(self, p):
        """obj : '(' objid attrs ')'"""
        if not all_unique([k for k, _ in p[3]]):
            raise Error('Attribute reassignment' + self.position(p, 3))
        p[0] = ConfObj(p[2], p[3])

    def p_objid(self, p):
        """objid : ID '-' number
                 | ID '-' number ':' number
        """
        try:
            otype = conf_obj_types[p[1]]
        except KeyError:
            raise Error('Unknown conf object type {!r}{}'.format(
                p[1], self.position(p, 1)))
        if len(p) == 4:
            p[0] = otype.to_fid(1, p[3])
        else:
            p[0] = otype.to_fid(p[3], p[5])

    def p_attrs(self, p):
        """attrs : attr
                 | attrs attr
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[2]]

    def p_attr(self, p):
        """attr : ID '=' number
                | ID '=' ENUM
                | ID '=' STRING
                | ID '=' objid
                | ID '=' fid
                | ID '=' list
        """
        p[0] = p[1], p[3]

    def p_list(self, p):
        """list : '[' ']'
                | '[' numbers ']'
                | '[' strings ']'
                | '[' objids ']'
        """
        p[0] = [] if p[2] == ']' else p[2]

    def p_objids(self, p):
        """objids : objid
                  | objids ',' objid
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[3]]


class Parser_xc(BaseParser):
    """Parses string in "xcode" format."""

    def __init__(self, **kwargs):
        self.lexer = Lexer_xc()
        self.start = 'xlist_xobj'
        super(self.__class__, self).__init__(**kwargs)

    def _check_xlist_len(self, position, expected, actual):
        if expected != actual:
            raise Error("""Bad list{}
Length ({}) != number of elements ({})""".format(position, expected, actual))

    def p_xlist_xobj(self, p):
        """xlist_xobj : xlist_empty
                     | '[' number ':' xobjs ']'
                     | empty
        """
        if len(p) == 6:
            self._check_xlist_len(self.position(p, 1), p[2], len(p[4]))
            p[0] = p[4]
        else:
            p[0] = []

    def p_xobjs(self, p):
        """xobjs : xobj
                 | xobjs ',' xobj
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[3]]

    def p_xobj(self, p):
        """xobj : '{' number '|' '(' '(' xobjid ')' ',' union_xattrs ')' '}'
        """
        t1, objid = p[2], p[6]
        union_tag, attrs = p[9]
        otype = ConfObjType.from_fid(objid)
        t2 = ord(otype.ft_id)
        if t1 != t2:
            raise Error("""Inconsistent object type{}
{t1:#x} != {t2:#x} ('{t2:c}')""".format(self.position(p, 2), t1=t1, t2=t2))
        if union_tag != otype.union_tag:
            raise Error('Invalid union specification' + self.position(p, 9))
        if len(attrs) != len(otype.attrs):
            raise Error('Wrong number of attributes' + self.position(p, 1))
        p[0] = ConfObj(objid, zip([a.name for a in otype.attrs], attrs))

    def p_xobjid(self, p):
        """xobjid : xfid
        """
        if ConfObjType.from_fid(p[1]) is None:
            raise Error('Invalid conf fid {}{}'.format(
                p[1], self.position(p, 1)))
        p[0] = p[1]

    def p_xfid(self, p):
        """xfid : fid
                | xfid_custom
        """
        p[0] = p[1]

    # Custom format is only used for conf_fids at the moment.
    def p_xfid_custom(self, p):
        """xfid_custom : '^' ID '|' number ':' number
        """
        p[0] = Fid((p[2], p[4]), p[6])

    def p_union_xattrs(self, p):
        """union_xattrs : xattrs
                        | '{' number '|' '(' xattrs ')' '}'
        """
        if len(p) == 2:
            p[0] = None, p[1]
        else:
            p[0] = p[2], p[5]

    def p_xattrs(self, p):
        """xattrs : xattr
                  | xattrs ',' xattr
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[3]]

    def p_xattr(self, p):
        """xattr : number
                 | ENUM
                 | STRING
                 | xfid
                 | xlist
        """
        p[0] = p[1]

    def p_xlist(self, p):
        """xlist : xlist_empty
                 | '[' number ':' numbers ']'
                 | '[' number ':' strings ']'
                 | '[' number ':' xobjids ']'
        """
        if p[1] == '[':
            nr, xs = p[2], p[4]
            self._check_xlist_len(self.position(p, 1), nr, len(xs))
            if nr > 1:
                assert len(set(map(type, xs))) == 1
                if type(xs[0]) is tuple and len(set([conf_obj_types[t].ft_id
                                                     for t, _ in xs])) > 1:
                    # xs is a list of xobjids; obj types differ
                    raise Error('Heterogeneous list' + self.position(p, 1))
            p[0] = xs
        else:
            p[0] = []

    def p_xlist_empty(self, p):
        """xlist_empty : '[' number ']'"""
        if p[2] != 0:
            raise Error("""Bad list%s
The length is non-zero, but there are no elements""" % self.position(p, 1))

    def p_xobjids(self, p):
        """xobjids : xobjid
                   | xobjids ',' xobjid
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[3]]


# See m0_fid_sscanf(), FID_F().
def fid_scan(s):
    """str -> Fid

    Parses a string in FID_F format.
    """
    assert type(s) is str

    m = re.match(r'\^(.)\|({0}):({0})\s*$'.format(r'\d+|0[xX][0-9a-fA-F]+'),
                 s)  # e.g. '^s|1:0'
    if m:
        c = [t.ft_id for t in conf_obj_types.values() if t.ft_id == m.group(1)]
        if not c:
            raise Error('Invalid fid (unknown fid type): ' + s)
        assert len(c) == 1
        container, key = [int(x, base=0) for x in (m.group(2), m.group(3))]
        return Fid((c[0], container), key)
    try:
        container, key = [int(x, base=16) for x in s.strip('<>').split(':', 1)]
        return Fid(container, key)
    except ValueError:
        raise Error('Invalid fid: ' + s)


def conf_objs_from_str(s, from_fmt):
    """conf_objs_from_str(string, format) -> list of ConfObj

    Converts input string of given format into a list of conf objects.
    """
    parsers = OrderedDict([('confgen', Parser_cg), ('xcode', Parser_xc)])
    assert list(parsers.keys()) == input_formats
    return parsers[from_fmt]().parse(s)


# --------------------------------------------------------------------
# Tests

if sys.version_info.major < 3:
    # unittest.TestCase.assertRaisesRegex does not exist in Python 2.
    # unittest.TestCase.assertRaisesRegexp is deprecated in Python 3.
    # Solve this issue by creating `assertRaisesRegex' alias for Python 2.
    unittest.TestCase.assertRaisesRegex = unittest.TestCase.assertRaisesRegexp


class TestInternalRepr(unittest.TestCase):

    def test_Fid(self):
        x = Fid(1, 2)
        self.assertEqual(x.tcontainer, (0, 1))
        self.assertEqual(x.typebyte(), 0)
        self.assertEqual(x.container(), 1)
        self.assertEqual(x.key, 2)
        self.assertEqual(repr(x), 'Fid(1, 2)')
        self.assertEqual(repr(x), str(x))
        self.assertEqual(x, Fid(1, 2))
        self.assertEqual(x, Fid((0, 1), 2))
        self.assertNotEqual(x, Fid(1, 1))

        y = Fid(('t', 1), 2)
        self.assertEqual(y.tcontainer, (0x74, 1))
        self.assertEqual(y.typebyte(), 0x74)
        self.assertEqual(y.container(), 0x7400000000000001)
        self.assertEqual(y.key, 2)
        self.assertEqual(repr(y), "Fid(('t', 1), 2)")
        self.assertEqual(repr(Fid((9, 1), 2)), 'Fid((9, 1), 2)')  # !isprint
        self.assertEqual(repr(Fid((0x23, 1), 2)), "Fid(('#', 1), 2)")
        self.assertEqual(y, Fid((0x74, 1), 2))
        self.assertEqual(y, Fid(0x7400000000000001, 2))
        self.assertNotEqual(y, x)
        self.assertEqual(Fid(('v', 0x40000000000002), 3),
                         Fid(0x7640000000000002, 3))
        self.assertRaises(ValueError, Fid, 0x6300000000000000001, 0x181)

    def test_ConfObjType(self):
        self.assertEqual(repr(conf_obj_types['profile']),
                         "ConfObjType('profile', 'p', '!pools=[objid]')")
        self.assertEqual(repr(conf_obj_types['pver_f']),
                         "ConfObjType('pver_f', 'v:1', 'id=NUMBER"
                         " !base=objid allowance=[NUMBER]')")
        # to_fid()
        self.assertEqual(conf_obj_types['service'].to_fid(2, 3),
                         Fid(('s', 2), 3))
        self.assertEqual(conf_obj_types['pver'].to_fid(2, 3),
                         Fid(('v', 2), 3))
        self.assertEqual(conf_obj_types['pver_f'].to_fid(2, 3),
                         Fid(('v', 0x40000000000002), 3))
        self.assertRaisesRegex(
            Error, 'Union tag bits are not zero: 0x40000000000000',
            conf_obj_types['pver'].to_fid, 0x0040000000000000, 0)
        self.assertRaises(AssertionError, conf_obj_types['pver'].to_fid,
                          0x7600000000000000, 0)
        # from_fid()
        self.assertIsNone(ConfObjType.from_fid(Fid(1, 1)))
        self.assertEqual(ConfObjType.from_fid(Fid(('t', 1), 2)),
                         conf_obj_types['root'])
        self.assertEqual(ConfObjType.from_fid(Fid(('v', 1), 4)),
                         conf_obj_types['pver'])
        self.assertEqual(ConfObjType.from_fid(Fid(0x7600000000000001, 4)),
                         conf_obj_types['pver'])
        self.assertEqual(ConfObjType.from_fid(Fid(0x7640000000000001, 5)),
                         conf_obj_types['pver_f'])
        self.assertRaisesRegex(
            Error, 'Unsupported union tag: 0x7680000000000001',
            ConfObjType.from_fid, Fid(0x7680000000000001, 5))

    def test_ConfObjAttrType(self):
        self.assertEqual(repr(conf_obj_types['root'].attrs[6]),
                         "ConfObjAttrType('*nodes', '[objid]')")

    def test_ConfObj(self):
        objv_0 = Fid(('j', 1), 0)
        site_0 = Fid(('S', 1), 0)
        x = ConfObj(objv_0, [('real', site_0), ('children', [])])
        self.assertEqual(
            repr(x),
            "ConfObj({!r}, [('real', {!r}), ('children', [])])".format(objv_0,
                                                                       site_0))
        self.assertEqual(x.attrs, [site_0, []])
        self.assertRaisesRegex(Error, """\
Fid\(\('j', 1\), 0\): Invalid attributes
  missing: children, real
  unknown: abc""", ConfObj, objv_0, [('abc', 0)])

        # Test __eq__() method.
        self.assertEqual(x,
                         ConfObj(objv_0, [('real', site_0), ('children', [])]))
        # The order of attributes does not matter.
        self.assertEqual(x,
                         ConfObj(objv_0, [('children', []), ('real', site_0)]))
        self.assertNotEqual(x,
                            ConfObj(objv_0, [('real', objv_0),
                                             ('children', [])]))


class DummyFile(object):

    def write(self, *_):
        pass

    def flush(self):
        pass


@contextlib.contextmanager
def nostdout():
    saved = sys.stdout
    sys.stdout = DummyFile()
    yield
    sys.stdout = saved


class TestCoverage(unittest.TestCase):

    def test_main(self):
        def test(argv):
            self.assertIsNone(main(argv))

        with nostdout():
            for mode in '--help-format', '--types', '--svc-types':
                test([mode])

            if os.path.isfile('ut/conf.cg'):
                for to_fmt in output_formats:
                    test(['-f', 'confgen', '-t', to_fmt, 'ut/conf.cg'])

            if os.path.isfile('ut/conf.xc'):
                for to_fmt in output_formats:
                    test(['-f', 'xcode', '-t', to_fmt, 'ut/conf.xc'])


class TestEncoding(unittest.TestCase):

    def test_typed(self):
        def test(desc, x, xcode, confgen):
            self.assertEqual(Encoder_xc.typed(desc)(x), xcode)
            self.assertEqual(Encoder_cg.typed(desc)(x), confgen)

        test('NUMBER', 99, '99', '99')
        test('NUMBER', 100, '0x64', '0x64')
        test('NUMBER', '@ENUM', '@ENUM', '@ENUM')
        test('STRING', 'abc', '"abc"', '"abc"')
        test('STRING', '', '""', '""')
        test('fid', Fid(1, 2), '(1, 2)', '(1, 2)'),
        test('fid', Fid(99, 100), '(99, 0x64)', '(99, 0x64)'),
        test('fid', Fid(('t', 1), 0), '^t|1:0', 'root-0'),
        test('objid', Fid(('t', 1), 0), '^t|1:0', 'root-0'),
        test('objid', Fid(('t', 0), 1), '^t|0:1', 'root-0:1'),
        test('objid', Fid(('v', 10), 11), '^v|10:11', 'pver-10:11'),
        test('objid', Fid(0x7640000000000001, 8),
             '^v|0x40000000000001:8', 'pver_f-8'),
        test('objid', Fid(('t', 100), 1), '^t|0x64:1', 'root-0x64:1'),
        test('objid', Fid(0x7640000000000001, 100),
             '^v|0x40000000000001:0x64', 'pver_f-0x64')
        for E in Encoder_xc, Encoder_cg:
            self.assertRaisesRegex(Error, 'Conf fid expected: Fid\(1, 2\)',
                                   E.typed('objid'), Fid(1, 2))
        for t in 'NUMBER', 'STRING', 'fid', 'objid':
            test('[' + t + ']', [], '[0]', '[]')
        test('[NUMBER]', [0, 1, 2], '[3: 0, 1, 2]', '[0, 1, 2]')
        test('[STRING]', ['a', 'b'], '[2: "a", "b"]', '["a", "b"]')
        test('[fid]', [Fid(1, 2), Fid(('p', 1), 1)],
             '[2: (1, 2), ^p|1:1]', '[(1, 2), profile-1]')

    def test_encode(self):
        def test(objs, xcode, confgen, json):
            self.assertEqual(Encoder_xc.encode(objs), xcode)
            self.assertEqual(Encoder_cg.encode(objs), confgen)
            self.assertEqual(Encoder_json.encode(objs), json)

        test([], '', '', '')
        test([ConfObj(Fid(('p', 1), 0), [('pools', [Fid(('o', 1), 4)])])],
             '[1:\n {0x70| ((^p|1:0), [1: ^o|1:4])}]',
             '(profile-0 pools=[pool-4])',
             '[\n {"objid": "profile-0", "pools": ["pool-4"]}\n]')
        test([ConfObj(Fid(('p', 1), 0),
                      [('pools', [Fid(('o', 1), 0), Fid(('o', 1), 1)])]),
              ConfObj(Fid(('o', 1), 0),
                      [('pver_policy', 0), ('pvers', [Fid(('v', 1), 0)])]),
              ConfObj(Fid(('o', 1), 1),
                      [('pver_policy', 0), ('pvers', [])])],
             """\
[3:
 {0x70| ((^p|1:0), [2: ^o|1:0, ^o|1:1])},
 {0x6f| ((^o|1:0), 0, [1: ^v|1:0])},
 {0x6f| ((^o|1:1), 0, [0])}]""",
             """\
(profile-0 pools=[pool-0, pool-1])
(pool-0 pver_policy=0 pvers=[pver-0])
(pool-1 pver_policy=0 pvers=[])""",
             """[
 {"objid": "profile-0", "pools": ["pool-0", "pool-1"]},
 {"objid": "pool-0", "pver_policy": 0, "pvers": ["pver-0"]},
 {"objid": "pool-1", "pver_policy": 0, "pvers": []}
]""")
        test([ConfObj(Fid(('v', 1), 8), [
            ('N', 1), ('K', 1), ('P', 5), ('tolerance', [0, 0, 0, 0, 1]),
            ('sitevs', [Fid(('j', 1), 12)])])],
             """[1:
 {0x76| ((^v|1:8), {0| (1, 1, 5, [5: 0, 0, 0, 0, 1], [1: ^j|1:12])})}]""",
             '(pver-8 N=1 K=1 P=5 tolerance=[0, 0, 0, 0, 1] sitevs=[objv-12])',
             """[
 {"objid": "pver-8", "N": 1, "K": 1, "P": 5, "tolerance": [0, 0, 0, 0, 1],\
 "sitevs": ["objv-12"]}
]""")
        test([ConfObj(Fid(0x7640000000000001, 9),
                      [('id', 0),
                       ('base', Fid(('v', 1), 8)),
                       ('allowance', [0, 0, 0, 0, 1])])],
             """[1:
 {0x76| ((^v|0x40000000000001:9), {1| (0, ^v|1:8, [5: 0, 0, 0, 0, 1])})}]""",
             '(pver_f-9 id=0 base=pver-8 allowance=[0, 0, 0, 0, 1])',
             """[
 {"objid": "pver_f-9", "id": 0, "base": "pver-8", "allowance": [0, 0, 0, 0, 1]}
]""")
        test([ConfObj(Fid(('s', 1), 9),
                      [('type', '@M0_CST_RMS'),
                       ('endpoints', ['0@lo:12345:34:1']),
                       ('params', ['abc', '123']),
                       ('sdevs', [])])],
             """[1:
 {0x73| ((^s|1:9), @M0_CST_RMS, [1: "0@lo:12345:34:1"], [2: "abc", "123"],\
 [0])}]""",
             '(service-9 type=@M0_CST_RMS endpoints=["0@lo:12345:34:1"]'
             ' params=["abc", "123"] sdevs=[])',
             """[
 {"objid": "service-9", "type": "@M0_CST_RMS",\
 "endpoints": ["0@lo:12345:34:1"], "params": ["abc", "123"], "sdevs": []}
]""")

    def test_html(self):
        self.assertEqual(Encoder_html.array_entries(
            ConfObj(Fid(('c', 1), 0),
                    [('drives', [Fid(('k', 1), 0), Fid(('k', 1), 1)]),
                     ('pvers', [Fid(('v', 1), 13)])])),
                         ("""\
{"id": "controller-0", "label": "controller-0", "group": "controller",\
 "_attrs": {"drives": "[drive-0, drive-1]",\
 "pvers": "[pver-13]"}}""",
                          ['{"from": "controller-0", "to": "drive-0"}',
                           '{"from": "controller-0", "to": "drive-1"}']))

    def test_dot(self):
        self.assertEqual(Encoder_dot.encode_ConfObj(
            ConfObj(Fid(('a', 1), 0), [('encls', [Fid(('e', 1), 0)]),
                                       ('pvers', [])])),
                         """\
    "rack-0";
    "dir_rack-0_encls" [height=0.15, width=0.15, label=""];
    "rack-0" -> "dir_rack-0_encls" [label="encls"];
    "dir_rack-0_encls" -> "enclosure-0";""")
        self.assertEqual(Encoder_dot.encode([
            ConfObj(Fid(('S', 1), 128), [
                ('racks', [Fid(('a', 1), 0)]), ('pvers', [Fid(('j', 1), 0)])]),
            ConfObj(Fid(('j', 1), 0), [
                ('real', Fid(('S', 1), 128)),
                ('children', [Fid(('j', 1), 1), Fid(('j', 1), 2)])])]),
                         """\
digraph conf {
    "site-0x80";
    "dir_site-0x80_racks" [height=0.15, width=0.15, label=""];
    "site-0x80" -> "dir_site-0x80_racks" [label="racks"];
    "dir_site-0x80_racks" -> "rack-0";
    "objv-0";
    "dir_objv-0_children" [height=0.15, width=0.15, label=""];
    "objv-0" -> "dir_objv-0_children" [label="children"];
    "dir_objv-0_children" -> "objv-1";
    "dir_objv-0_children" -> "objv-2";
}""")

    def test_fid_translate(self):
        self.assertEqual(fid_translate(Fid(('p', 1), 0)), 'profile-0')
        self.assertEqual(fid_translate(Fid(1, 2)), None)
        self.assertEqual(fid_translate(Fid(('D', 0x73640000000001), 9)),
                         'dir_service-9_sdev')
        self.assertEqual(fid_translate(Fid(('D', 0x6a6a0000000001), 59)),
                         'dir_objv-59_objv')
        self.assertEqual(fid_translate(Fid(('D', 0x6a780000000001), 59)), None)
        self.assertEqual(fid_translate(Fid(('v', 0x40000000000001), 65)),
                         'pver_f-65')
        self.assertEqual(fid_translate(Fid(('v', 2), 8)), 'pver-2:8')
        self.assertEqual(fid_translate(Fid(('D', 0x766a0000000001), 8)),
                         'dir_pver-8_objv')
        self.assertEqual(fid_translate(Fid(('s', 0x73650000000001), 7)),
                         'service-0x73650000000001:7')
        self.assertEqual(fid_translate(
            Fid(0x2f00000000000000, 0xffffffffffffffff)), 'M0_CONF_ANY_FID')
        self.assertEqual(fid_translate(
            Fid(0x2f00000000000000, 19)), 'M0_CONF_CONTROLLER_DRIVES_FID')
        self.assertIsNone(fid_translate(Fid(0x2f00000000000000, 0)))


class TestDecoding(unittest.TestCase):

    def test_Parser_cg(self):
        decode = Parser_cg().parse
        self.assertEqual(decode(''), [])
        self.assertEqual(decode('# comment'), [])
        self.assertEqual(decode('(site-128 racks=[rack-0] pvers=[])'),
                         [ConfObj(Fid(('S', 1), 128), [
                             ('racks', [Fid(('a', 1), 0)]), ('pvers', [])])])
        self.assertEqual(decode(
            '(pver-10 N=2 K=1 P=4 tolerance=[0, 0, 0, 0, 1] sitevs=[objv-2])'),
                         [ConfObj(Fid(('v', 1), 10), [
                             ('N', 2), ('K', 1), ('P', 4),
                             ('tolerance', [0, 0, 0, 0, 1]),
                             ('sitevs', [Fid(('j', 1), 2)])])])
        self.assertEqual(decode(
            '(pver_f-66 id=0 base=pver-8 allowance=[0, 0, 0, 0, 1])'),
                         [ConfObj(Fid(('v', 0x40000000000001), 66), [
                             ('id', 0), ('base', Fid(('v', 1), 8)),
                             ('allowance', [0, 0, 0, 0, 1])])])
        self.assertEqual(decode(
            '(service-9 type=@M0_CST_RMS endpoints=["0@lo:12345:34:1"]\
 params=["abc", "123"] sdevs=[])'),
                         [ConfObj(Fid(('s', 1), 9), [
                             ('type', '@M0_CST_RMS'),
                             ('endpoints', ['0@lo:12345:34:1']),
                             ('params', ['abc', '123']),
                             ('sdevs', [])])])
        self.assertRaisesRegex(
            Error, "Unknown conf object type 'woot' at byte 2",
            decode, '(woot-0 verno=1 profiles=[])')
        self.assertRaisesRegex(Error, 'Attribute reassignment at byte 9',
                               decode, '(root-0 verno=1 verno=2 profiles=[])')
        self.assertRaisesRegex(
            Error, 'Syntax error at byte 10',
            decode, '(service-@ENUM type=4 endpoints=[] params=[] sdevs=[])')
        # The order of attributes does not matter.
        self.assertEqual(decode('(objv-61 real=drive-55 children=[])'),
                         decode('(objv-61 children=[] real=drive-55)'))

    def test_Parser_xc(self):
        decode = Parser_xc().parse
        self.assertEqual(decode(''), [])
        self.assertEqual(decode('# comment'), [])
        self.assertEqual(decode('[0]'), [])
        self.assertEqual(decode("""[1:
 {0x53| ((^S|1:0x80), [1: ^a|1:0], [0])}]"""),
                         [ConfObj(Fid(('S', 1), 128),
                                  [('racks', [Fid(('a', 1), 0)]),
                                   ('pvers', [])])])
        self.assertRaisesRegex(
            Error, "Invalid conf fid Fid\(\('X', 1\), 0\) at byte 14",
            decode, '[1: {0x58| (((0x5800000000000001, 0)), 1, [0])}]')
        self.assertRaisesRegex(
            Error, 'Wrong number of attributes at byte 5',
            decode, '[1: {0x74| (((0x7400000000000001, 0)), 1)}]')

    def test_fid_scan(self):
        self.assertEqual(fid_scan('7000000000000001:0'), Fid(('p', 1), 0))
        self.assertEqual(fid_scan('<446a6a0000000001:3b>'),
                         Fid(('D', 0x6a6a0000000001), 59))
        self.assertEqual(fid_scan('<7640000000000001:41>'),
                         Fid(('v', 0x40000000000001), 65))

        self.assertEqual(fid_scan('0:0'), Fid(0, 0))
        self.assertEqual(fid_scan('<0:0>'), Fid(0, 0))
        self.assertEqual(fid_scan('10:10'), Fid(16, 16))
        self.assertEqual(fid_scan('<10:10>'), Fid(16, 16))
        self.assertEqual(fid_scan('0x10:0x10'), Fid(16, 16))
        self.assertEqual(fid_scan('<0x10:0x10>'), Fid(16, 16))

        self.assertEqual(fid_scan('^n|1:2'), Fid(('n', 1), 2))
        self.assertEqual(fid_scan('^n|10:10'), Fid(('n', 10), 10))
        self.assertEqual(fid_scan('^n|0x10:0x10'), Fid(('n', 16), 16))

        self.assertRaises(Error, fid_scan, '')
        self.assertRaisesRegex(Error, 'Invalid fid: invalid_fid',
                               fid_scan, 'invalid_fid')
        self.assertRaises(Error, fid_scan, '<446a6a00000000')
        self.assertRaises(Error, fid_scan, '6300000000000000001:181')
        self.assertRaisesRegex(Error, 'Invalid  fid (unknown fid type): ?|1:0',
                               fid_scan, '?|1:0')
        self.assertRaisesRegex(Error, 'Invalid  fid: n|1:2', fid_scan, 'n|1:2')


# --------------------------------------------------------------------
# main()

def main(argv=None):
    p = argparse.ArgumentParser(
        usage='%(prog)s [OPTION]... [FILE]',
        description='Converts configuration string from one format into'
        ' another.')
    p._optionals.title = 'Options'
    p.add_argument('--help-format',
                   help='print confgen format description and exit',
                   action='store_true')
    p.add_argument('-f', '--from', metavar='FMT', choices=input_formats,
                   dest='from_fmt', default='confgen',
                   help="input format: {}; default is `confgen'".format(
                       ', '.join(input_formats)))
    p.add_argument('-t', '--to', metavar='FMT', choices=output_formats,
                   dest='to_fmt', default='xcode',
                   help="output format: {}; default is `xcode'".format(
                       ', '.join(output_formats)))
    g = p.add_mutually_exclusive_group()
    g.add_argument('--types', help='print conf object types and exit',
                   action='store_true')
    g.add_argument('--svc-types', help='print service types and exit',
                   action='store_true')
    g.add_argument('--fids', help='read FIDs from stdin and show them in'
                   ' human-friendly format', action='store_true')
    g.add_argument('--self-check', help='run unit tests and exit',
                   action='store_true')
    g.add_argument('-V', '--version', action='version',
                   version='%(prog)s ' + __version__)
    g = p.add_argument_group('Positional argument')
    g.add_argument('file', metavar='FILE', nargs='?', default='-',
                   help='Input file. With no FILE, or when FILE is -,'
                   ' read standard input.')
    args = p.parse_args(argv)

    if args.self_check:
        unittest.main(argv=sys.argv[:1])  # calls sys.exit()

    if args.help_format:
        print(confgen_doc)
        return
    if args.types:
        types = list(conf_obj_types.items())
        types.sort(key=lambda kv: kv[1].ft_id)
        for k, v in types:
            print('{} {:#x} {}'.format(v.ft_id, ord(v.ft_id), k))
        return
    if args.svc_types:
        assert conf_service_types[0] == 'M0_CST__UNUSED'
        for i, s in enumerate(conf_service_types[1:]):
            print('{} {}'.format(i+1, s))
        return
    if args.fids:
        return fids_translate()

    if args.file == '-':
        f = sys.stdin
    else:
        try:
            f = open(args.file)
        except IOError as e:
            print(e, file=sys.stderr)
            return e.errno

    try:
        print(conf_objs_to_str(conf_objs_from_str(f.read(), args.from_fmt),
                               args.to_fmt))
    except Error as e:
        print(e, file=sys.stderr)
        return 1
    except IOError as e:
        if e.errno == EPIPE:
            return e.errno
        raise
    finally:
        if f != sys.stdin:
            f.close()


__doc__ = __doc__.format(input_formats=', '.join(input_formats),
                         output_formats=', '.join(output_formats))


if __name__ == '__main__':
    sys.exit(main())
