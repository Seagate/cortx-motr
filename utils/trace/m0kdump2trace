#!/usr/bin/env bash
#
# Copyright (c) 2020 Seagate Technology LLC and/or its Affiliates
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# For any questions about this software or licensing,
# please email opensource@seagate.com or cortx-questions@seagate.com.
#


# This script extracts trace buffer of Motr kernel module from linux kernel
# crash dump (vmcore), produced by kdump service. Essentially, it's a wrapper
# around `crash` utility.


#
# Global vars
#

# constants
readonly PROG_NAME=$(basename $0)
readonly THIS_SCRIPT=$(readlink -f $0)
readonly stdin='/dev/fd/0'
readonly stdout='/dev/fd/1'
readonly vmlinux="/usr/lib/debug/lib/modules/$(uname -r)/vmlinux"

# variables
verbose=false
force=false
module_img=false
address=
size=
cli_args=
infile=$stdin
outfile=$stdout


#
# Usage
#

help()
{
    [[ $1 == stdout ]] && usage || usage >&2
    exit 1
}

usage()
{
    cat <<USAGE_END
Usage: $PROG_NAME [-h|--help] [-v|--verbose] [-f|--force] [-m|--module-image]
                  [-a|--address addr] [-s|--size size]
                  [[vmcore] [output-file]]

  Arguments are optional. If not specified, STDIN and STDOUT are used for
  <vmcore> and <output-file> respectively.

    vmcore          Kernel crash dump image, generated by kdump.

    output-file     Output file, where binary Motr trace buffer will be stored.
                    If '-m|--module-image' is used, then instead of a trace
                    buffer, a m0tr.ko module image is extracted.

  OPTIONS:

    -f|--force      Don't ask to overwrite if output file <trace_buffer> already
                    exists.

    -m|--module-image

                    Extract m0tr.ko module image instead of a trace buffer.
                    This image is required on the next step by m0tracedump to
                    decode trace buffer.

    -a|--address <addr>

                    In memory address of either a trace buffer or a module image
                    (if '-m|--module-image' is provided).

    -s|--size <size>

                    Size of the module image, effective only when
                    '-m|--module-image' is provided.

    -v|--verbose    Print what's going on to STDERR.

    -h|--help       Print this help screen.
USAGE_END
}


#
# Parse CLI options
#

parse_cli_options()
{
    # Note that we use `"$@"' to let each command-line parameter expand to a
    # separate word. The quotes around `$@' are essential!
    # We need TEMP as the `eval set --' would nuke the return value of getopt.
    TEMP=$( getopt --options hvfma:s: \
                   --longoptions help,verbose,force,module-image,address:,size: \
                   --name "$PROG_NAME" -- "$@" )

    [[ $? -ne 0 ]] && help

    # Note the quotes around `$TEMP': they are essential!
    eval set -- "$TEMP"

    while true ; do
        case "$1" in
            -h|--help)          help stdout ;;
            -v|--verbose)       verbose=true; shift ;;
            -f|--force)         force=true; shift ;;
            -m|--module-image)  module_img=true; shift ;;
            -a|--address)       address=$2; shift 2 ;;
            -s|--size)          size=$2; shift 2 ;;
            --)                 shift; break ;;
            *)                  echo 'getopt: internal error...'; exit 1 ;;
        esac
    done

    # remaining command line arguments
    cli_args="$@"
}


#
# Utility functions
#

echo_err()
{
    echo -e "$*" >&2
}

die()
{
    echo_err "$PROG_NAME:  ERROR:  $*"
    exit 1
}

log()
{
    ! $verbose || echo_err "$PROG_NAME: $@"
}

run_crash_cmd()
{
    local cmd=$1

    local cmd_file=$(mktemp $PROG_NAME.XXXX.cmd)
    local result=

    echo "$cmd" > $cmd_file

    result=$(echo -e "exit\n" | crash -s -i $cmd_file $vmlinux $infile)
    rm $cmd_file
    echo "$result"
}

m0tracedump()
{
    local trace_dump=

    case $THIS_SCRIPT in
        /usr/bin/*)      trace_dump=/usr/bin/m0tracedump ;;
        */motr/utils/*)  trace_dump="$(dirname $THIS_SCRIPT)/m0tracedump" ;;
        *)               die "m0tracedump cannot be found in the PATH" ;;
    esac

    $trace_dump "$@"
}

crash_log=
get_value_from_crash_log()
{
    local log_entry=$1

    if [[ -z "$crash_log" ]] ; then
        crash_log=$(run_crash_cmd 'log')
    fi

    local value=$(echo "$crash_log" |
                 perl -e "while (<>) {
                            /motr: $log_entry: ((?:0x)?[0-9a-fA-F]+)/;
                            \$value = \$1 if \$1;
                          }
                          END{ print \$value; }")
    echo "$value"
}

get_header_address()
{
    readonly hdr_magic='33dec0ded502ce77'

    # example output of the 'crash search <addr>' command:
    #   ffff88007ade9000: 33dec0ded502ce77
    #   ffffc90002fab000: 33dec0ded502ce77
    echo 0x$(run_crash_cmd "search $hdr_magic" | cut -d: -f1 | tail -n1)
}

get_header_value_of()
{
    local field=$1

    [[ -n "$field" ]] ||
        die "trace header field can't be empty in query"

    perl -MYAML::XS -e "
        local \$/; # slurp mode ON
        print YAML::XS::Load(<>)->{header}->{$field}
    "
}

#
# Main
#

# exit immediately if one the commands exits with a non-zero status
set -e

parse_cli_options "$@"
eval set -- "$cli_args"

#
# sanity checks

[[ -e $vmlinux ]] ||
    die "$vmlinux file doesn't exist, please install 'kernel-debuginfo' package!"

[[ -z "$1" ]] || infile=$1
[[ -z "$2" ]] || outfile=$2

if (! $force) && [[ $outfile != $stdout && -e $outfile ]] ; then
    echo -n 'Warning, '$outfile' already exists, overwrite? [y/N] '
    read answer
    [[ $answer =~ [yY] ]] || exit 0
fi

if $module_img && [[ -z "$address" && -n "$size" || -n "$address" && -z "$size" ]] ; then
    die "option -m requires that -a and -s options are either omitted or both provided"
fi

#
# dump trace header

if ! $module_img || [[ -z "$address" ]] ; then
    log 'finding memory location of a trace header...'
    [[ -n "$address" ]] ||
        address=$(get_header_address)
    log "trace header address: $address"

    log 'dumping trace header..'
    end_address=$(printf 0x%x $(($address + 4 * 1024)))
    trace_header=$(mktemp $PROG_NAME.XXXX.hdr)
    trap "rm $trace_header" EXIT
    run_crash_cmd "dump binary memory $trace_header $address $end_address" > /dev/null

    if $module_img ; then
        address=
    fi
fi

if $module_img ; then
    #
    # dump m0tr.ko image

    log 'finding memory location of m0tr.ko core image..'
    [[ -n "$address" ]] ||
        address=$(m0tracedump -H -i $trace_header | get_header_value_of 'mod_core_addr')
    log "m0tr.ko core address: $address"

    [[ -n "$size" ]] ||
        size=$(m0tracedump -H -i $trace_header | get_header_value_of 'mod_core_size')
    log "m0tr.ko core size: $size"

    log 'dumping m0tr.ko core image..'
    end_address=$(printf 0x%x $(($address + $size)))
    run_crash_cmd "dump binary memory $outfile $address $end_address" > /dev/null
    log 'done'
else
    #
    # dump trace buffer

    log 'getting actual size of header and buffer..'
    address=$(m0tracedump -H -i $trace_header | get_header_value_of 'header_addr')
    hdr_size=$(m0tracedump -H -i $trace_header | get_header_value_of 'header_size')
    buf_size=$(m0tracedump -H -i $trace_header | get_header_value_of 'buffer_size')
    log "trace header addr (real): $address"
    log "trace header size: $hdr_size"
    log "trace buffer size: $buf_size"

    log 'dumping trace buffer..'
    end_address=$(printf 0x%x $(($address + $hdr_size + $buf_size)))
    run_crash_cmd "dump binary memory $outfile $address $end_address" > /dev/null
    log 'done'
fi
